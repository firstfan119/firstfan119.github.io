<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅究HAc+NaOH水解平衡离子含量</title>
    <url>/2019/12/10/%E9%86%8B%E9%85%B8%E5%92%8C%E6%B0%A2%E6%B0%A7%E5%8C%96%E9%92%A0%E6%B7%B7%E5%90%88%E7%9A%84%E6%B0%B4%E8%A7%A3%E5%B9%B3%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>最近，我们的wjd王先生被一道高中的水解平衡题目的离子含量定性比较给难住了，在下觉得解答的过程很精妙，于是在此做出此题的解答。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>王先生喜欢中和反应。他左手有一瓶pH=2的HAc(CH3COOH)溶液，右手有一瓶pH=12的NaOH溶液，且这两瓶溶液体积相同。</p><p>王先生喜欢变魔术，于是他把两瓶溶液倒在了一起。他想知道，此时溶液中各离子的含量大小关系，请你来帮他一下。</p><a id="more"></a>


<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="酸碱性"><a href="#酸碱性" class="headerlink" title="酸碱性"></a>酸碱性</h3><p>显然，这是个水解平衡问题，如果是强酸强碱中和，那么pH应当为7，显中性，但是醋酸是弱酸，为了表现出pH=2，它需要比pH=2的盐酸溶液更高的HAc浓度。</p>
<p>也就是说，如果是盐酸，而这反应完毕后就是<del>一锅汤</del>NaCl溶液，显中性，但是此时弱酸过量，也就是说反应后$c(H^+)&gt;c(OH^-)$。</p>
<h3 id="过量的醋酸根"><a href="#过量的醋酸根" class="headerlink" title="过量的醋酸根"></a>过量的醋酸根</h3><p>随后，我们发现NaOH和HAc的反应是这样的：</p>
<p>$NaOH+HAc==NaAc+H_2O$</p>
<p>也就是说，现在溶液中有多少$Na^+$，就有多少的$HAc$发生了中和反应。从上文可以知道还有一部分没发生反应的HAc会电离出$Ac^-$，所以溶液中$c(Ac^-)&gt;c(Na^+)$。</p>
<h3 id="阳离子浓度比较"><a href="#阳离子浓度比较" class="headerlink" title="阳离子浓度比较"></a>阳离子浓度比较</h3><p>最麻烦的问题来了：如何比较$c(Na^+)$和$c(H^+)$的大小？</p>
<p>这就需要一定的数学推导了(思路来自数竞大佬kjy)</p>
<p>首先写下电离方程式：</p>
<p><img src="https://i.loli.net/2019/12/10/inUeCvAsjEySaG2.png" alt="电离方程式"></p>
<p>然后我们此处已知氢离子浓度/pH，但是我们假装不知道，假设混合之前，在wjd手上的那瓶HAc中，HAc的浓度是x，$H^+$和$Ac^-$的浓度都是y。</p>
<p>所以我们可以得到醋酸的电离平衡常数：</p>
<p><img src="https://i.loli.net/2019/12/10/iQqyJlgYOBxshk1.png" alt="电离平衡常数"></p>
<p>继续，我们按照步骤把溶液中和，此时HAc过量，上述的电离仍然在进行，由于温度并没有发生改变，$K_a$仍然不变。</p>
<p>但是在等体积的两种溶液混合后，不考虑生成的水，所有溶质的浓度都要折半，而氢离子被完全消耗，即：</p>
<p>$$\left{\begin{matrix}c(HAc)=\frac{x}{2}\c(H^+)=0\c(Ac^-)=\frac{y}{2}\end{matrix}\right.$$</p>
<p>那么我们假设有$\omega$浓度的HAc被转化，写出三段式：</p>
<p><img src="https://i.loli.net/2019/12/10/Nhc7paxM4gIJ9fY.png" alt="三段式"></p>
<p>那么由于$K_a$没有发生变化，我们可以得到关系式：</p>
<p><img src="https://i.loli.net/2019/12/10/Ukg2WXTIGcH3uwS.png" alt="电离常数不变的关系转化"></p>
<p>那么我们来分步解方程，首先是$\Delta$。</p>
<p><img src="https://i.loli.net/2019/12/10/pfSIy7UajgV5WwJ.png" alt="解delta"></p>
<p>发现$\Delta$有一步奇妙的一次放缩机会，仿佛……求根公式中可以抵消掉一点什么！</p>
<p><img src="https://i.loli.net/2019/12/10/8VTsAhQnYgqtk4N.png" alt="求根公式"></p>
<p>回头看一眼$\frac{y}{2}$的含义？竟然是$\large\text{钠离子浓度！}$</p>
<p>因为此时的氢离子全部被转化而来，所以$\omega$就是$\large\text{氢离子浓度！}$</p>
<p>所以我们得到了结论：</p>
<p>$$\huge c(Na^+)&gt;c(H^+)$$</p>
<p>最后，我们进行一次完整的排序：</p>
<p>$$\Large c(Ac^-)&gt;c(Na^+)&gt;c(H^+)&gt;c(OH^-)$$</p>
<p>得到最终答案。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>简而言之，要定性分析离子浓度并不麻烦，只要能把握住<strong>平衡常数</strong>这样的不变量进行混合前混合后的分析，加之解方程求解范围即可，此题比较特殊，是一个恒成立现象。</p>
<p>你发现了吗？在忽略水的电离的条件下，其实pH对$c(Na^+)$和$c(H^+)$的大小关系并无影响，所以只要保证混合前二者pH不接近于pH=7，上述的关系就一定存在啦~</p>
<p>By first_fan</p>
<p>2019.12.10</p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo搭博教程</title>
    <url>/2019/12/06/hexo-build-up/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这里介绍了一种利用github托管的hexo静态博客搭建方法，也是此博客的搭建方法，较为易懂。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>node.js</li>
</ul><p><img src="https://programmerblog.net/wp-content/uploads/2017/07/generate-pdf-using-nodejs-thumbnail.png" alt="node.js"></p><p><a href="https://nodejs.org/dist/v12.13.1/node-v12.13.1-x64.msi" target="_blank" rel="noopener">Win x64官方下载地址</a></p><blockquote>
<p>备注：安装速度较慢，请耐心等待。安装完成后，可在cmd.exe中输入命令行：</p>
</blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>若显示出node.js版本信息则安装成功。</p><ul>
<li>Git</li>
</ul><p><img src="https://codereviewvideos.com/blog/wp-content/uploads/2015/06/git-goodness.gif" alt="Git"></p><p><a href="https://www.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">Git for win官方下载地址</a></p><a id="more"></a>










<blockquote>
<p>备注：安装速度较慢，请耐心等待。安装完成后，可在cmd.exe中输入命令行：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure>

<p>若显示出git语法及帮助则安装成功。</p>
<ul>
<li>Github账号【建议使用代理进行注册】</li>
</ul>
<p><img src="https://cn.bing.com/th?id=OIP.piAMkLAjuBhL3mIPbPgROgHaDm&pid=Api&rs=1" alt="github"></p>
<p><a href="https://github.com/" target="_blank" rel="noopener">访问github.io</a></p>
<ul>
<li>一款综合文本编辑器【推荐vscode/sublime】</li>
</ul>
<p><img src="https://i.loli.net/2019/12/06/yCmaBLzqUSTIiD2.png" alt></p>
<p><img src="https://i.loli.net/2019/12/06/f67rij1pdzn3QoZ.png" alt></p>
<p>建议安装html和javascript代码高亮插件，便于日后修改样式。</p>
<h2 id="Ⅰ-github的SSH-key设置"><a href="#Ⅰ-github的SSH-key设置" class="headerlink" title="Ⅰ.github的SSH key设置"></a>Ⅰ.github的SSH key设置</h2><p>安装完上述软件后，来到git根目录下，运行git-bash.exe</p>
<p><img src="https://i.loli.net/2019/12/06/gviErjmn6C1ORbf.png" alt="git-bash.exe"></p>
<p>输入命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;name@mail.com&quot;</span><br><span class="line"></span><br><span class="line">*此处的name@mail.com需改成注册github时所用的邮箱</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/06/3ZsGEzorK2XNmh5.png" alt="sshkey"></p>
<p>此处会要求输入加密信息，不进行加密，回车即可。</p>
<p>随后来到C盘下的用户目录，找到.ssh文件夹，用记事本打开内部的<code>id_rsa.pub</code>文件，<code>ctrl+A</code>复制全文。</p>
<p><img src="https://i.loli.net/2019/12/06/sYA9rWizGwpvfP5.png" alt="ssh文件夹"></p>
<p>访问<a href="https://github.com/settings/ssh/new" target="_blank" rel="noopener">github的新建ssh key页面</a>，将剪贴板内内容直接复制进<code>key</code>栏中，<code>title</code>栏随个人爱好填写，并点击<code>add ssh key</code>。</p>
<h2 id="Ⅱ-配置hexo"><a href="#Ⅱ-配置hexo" class="headerlink" title="Ⅱ.配置hexo"></a>Ⅱ.配置hexo</h2><p>确定好博客的本地位置，此处在下采用的是<code>E:\Blog</code>作为博客目录。</p>
<p>在cmd.exe中输入cd命令，进入到博客文件夹下(以下所有过程中，请勿关闭cmd):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:</span><br><span class="line">cd E:\Blog</span><br></pre></td></tr></table></figure>

<p>访问<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>，复制首页的安装代码，并在cmd.exe中输入命令行进行框架安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>当命令输入行再次出现时，hexo基础框架安装完毕。</p>
<blockquote>
<p>备注：安装较慢，但若长时间无响应，则可以尝试使用ctrl+C重置后再次安装（可能需要删除文件夹📂）。</p>
</blockquote>
<p>在cmd中输入命令行（注意，此时地址位于blog文件夹下）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init nameofblog</span><br><span class="line"></span><br><span class="line">*其中nameofblog可替换为按照喜好进行更改</span><br></pre></td></tr></table></figure>

<p>当安装完成后，输入命令行进入到博客根目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nameofblog</span><br></pre></td></tr></table></figure>

<p>安装node.js下载框架，输入命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>随后访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到默认的landscape的博客内容了。</p>
<p><img src="https://i.loli.net/2019/12/06/ONxMhD13evSkP2o.png" alt="Hello World!"></p>
<blockquote>
<p>备注：初始博客应当只附带一篇hello world使用教程，此处在下未复原初始状态进行演示。</p>
</blockquote>
<h2 id="Ⅲ-hexo上传"><a href="#Ⅲ-hexo上传" class="headerlink" title="Ⅲ.hexo上传"></a>Ⅲ.hexo上传</h2><p>现在，我们就可以进入博客根目录下，找到<code>/source/_posts</code>文件夹，并且以<strong>markdown</strong>的形式(.md文件)撰写博文了。</p>
<p><img src="https://i.loli.net/2019/12/06/uEqNAkeKHhjfCVO.png" alt="新建.md文档并开始写博吧~"></p>
<p>为了能让互谅网(梗)的广大朋友们看到我们的博客，我们要把整个博客上传到username.github.io，随后所有人都可以使用这个网址进行访问了。</p>
<p>首先，登录github账号，并新建一个repo，名字叫做<strong>username.github.io</strong>(其中的username请自行更换，repo名必须是username.github.io格式，不得修改！)</p>
<p><img src="https://ae01.alicdn.com/kf/H594a4fa6e92e4ebf9cd929ea387d85f9c.png" alt="repo预览"></p>
<blockquote>
<p>备注：此处在下没有复原repo进行演示，原本应为空仓或仅有readme.md等初始文件，主要强调repo名称必须正确。</p>
</blockquote>
<p>随后，进入到<strong>博客根目录</strong>下，找到<code>_config.yml</code>文件，后文中我们称之为<code>博客配置文件</code>，用文本编辑器打开进行查看。</p>
<p><img src="https://i.loli.net/2019/12/06/4TxPvHB9SwkguIb.png" alt="_config.yml"></p>
<p>打开后，ctrl+F搜索deploy，找到deploy所在的页尾处，并加以修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="string">*username应更换为自己的github用户名。</span></span><br></pre></td></tr></table></figure>

<p>然后搜索url，进行修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io</span></span><br></pre></td></tr></table></figure>

<p>打开cmd.exe并cd到<strong>博客根目录下</strong>，就是上述blog文件夹中的nameofblog文件夹，输入命令行安装hexo deployer heroku：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd E:</span><br><span class="line">cd E:\Blog\nameofblog</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br></pre></td></tr></table></figure>

<p><img src="https://ae01.alicdn.com/kf/H710413b632644dcbbe585b07d1a76081q.png" alt="安装deployer"></p>
<p>安装完毕后，输入两个命令行进行github-ssh绑定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;name@mail.com&quot;</span><br><span class="line">*此处邮箱填写github相关邮箱</span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">*此处username填写github用户名</span><br></pre></td></tr></table></figure>

<p>接下来我要简单介绍下hexo的三个常用指令：</p>
<h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><p>将_posts中的文章按日期归档，集合生成一个index.html下的页面树形结构（可以视作生成链接逻辑结构）。</p>
<h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><p>将目前生成的文章及插件、配置等更新并push到username.github.io上。</p>
<h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><p>将博客映射到本地局域网(localhost)的4000端口上(4000是默认值，也可以设置为别的端口)。</p>
<p>特别的是，当你修改并保存文章、配置时，刷新localhost页面，效果会直接改变，从而达到查看效果的功能：在localhost查看，修改好了再push到github上。</p>
<p>此处，我们需要先后输入命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>如果是第一次操作，会要求登录GitHub账号，按要求登录对应账号即可。</p>
<p>现在，我们可以登陆到username.github.io看看你的上传是否成功啦~（若不显示请稍等1-2min）</p>
<h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2>

<iframe src="//player.bilibili.com/player.html?aid=24897960&cid=42007944&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>随机化の美学</title>
    <url>/2019/11/23/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BE%8E%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="0-Brief-Intro"><a href="#0-Brief-Intro" class="headerlink" title="0.Brief Intro"></a>0.Brief Intro</h1><p>随机化算法在我们日常做题当中的应用可谓是少之又少，如遇<a href="https://www.luogu.org/problemnew/show/P1337" target="_blank" rel="noopener">LuoGu1337</a>这样的题目，我们往往不会考虑模拟退火，而是去考虑<a href="https://www.luogu.org/blog/user54214/solution-p1337" target="_blank" rel="noopener">半平面切割凸包</a>这样正常的解法。</p><p>但随机化在日常生活中应用广泛：从决定命运的$\sf \text{掷骰子}$到较为复杂而高效的$\sf \text{Pollard\ Rho因数分解算法}$，随处可见随机化的身影。</p><a id="more"></a>

<h1 id="1-First-impression"><a href="#1-First-impression" class="headerlink" title="1.First impression"></a>1.First impression</h1><p>恰如其名，随机化就是一种特殊的暴力，打个比方：</p>
<p><code>假如你要做一篇阅读题，普通暴力是逐字逐句读找到答案，随机化是一目十行寻找答案。</code></p>
<p>我在做阅读题时使用的是第二种方法，只不过随机范围较小。这种方法的利弊就不必多言：</p>
<ul>
<li><p>利：对于某些有序数据（好比是含有一段无用文字的文章），随机化能够概率跳过不看，从而更快地找到答案。</p>
</li>
<li><p>弊：对于差异很大的数据（好比是字字珠玑的一段），随机化可能浅尝辄止。</p>
</li>
</ul>
<p>至于百科上则是这样描述它的：</p>
<blockquote>
<p>只是由于随机化算法比较难于掌控，所以并不是很多人都接触过。</p>
</blockquote>
<blockquote>
<p>随机化算法是一个很好的概率算法，但是它并不能保证正确。</p>
</blockquote>
<p>这两句话就好像在说：<code>你人很好,但你是个好人。</code></p>
<p>随机化真的如此危险？竞赛中宁可暴力也不随机？抬头看标题：$\Large\sf\text{随机化美学}$</p>
<h1 id="2-随机化算法串讲"><a href="#2-随机化算法串讲" class="headerlink" title="2.随机化算法串讲"></a>2.随机化算法串讲</h1><p>显然，随机化的应用并不罕见，如果要我列出一个算法的集子来，我会说：<code>I can do this all day.</code>接下来将对随机化算法进行讲解（非难度排序）</p>
<h2 id="1°是非状态随机化"><a href="#1°是非状态随机化" class="headerlink" title="1°是非状态随机化"></a>1°是非状态随机化</h2><p>所谓是非状态，就是说类似背包内的取与不取两种状态，不是取就是不取。显然，最原始暴力，我们只要对每个物体枚举2种可能，那么最差（全放下）也就$\Large{2^n}$种可能性而已。</p>
<p>先不讨论背包的正解（无价值），我们来拿另一个例子想想如何随机化。（背包的随机化稍后与模拟退火同讲）</p>
<p><a href="https://www.luogu.org/problemnew/show/CF888E" target="_blank" rel="noopener">CF888E</a></p>
<p>另：此题详细题解在<a href="https://firstfan.blog.luogu.org/solution-cf888e" target="_blank" rel="noopener">我的另一文章</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给一个数列和m，在数列任选若干个数，使得他们的和对m取模后最大</span><br></pre></td></tr></table></figure>

<p>我们发现，这种序列选数求某个最值的题目往往可以随机拿分。</p>
<p>我们可以随机每个数选或者不选，并且如法炮制<code>数万甚至数十万次</code>并且<code>不断与之前最值打擂台</code>，在数十万次尝试下最值出现的概率很高。</p>
<p>针对此题，我们可以随机两回，随机选多少个数，随机每次选哪个数，再加个$vis[]$记录下是否使用就行。</p>
<p>如果看过我的题解，你可能会惊叹于$for()$循环的常数：50000！这就是是非状态随机化的一大特点：<code>多试几次</code>。</p>
<p>你不必担心跑得慢，因为正解那边折半搜索也是指数级的，稳妥为上。</p>
<p>总结一下，是非状态随机化适用于$\large\sf\text{数据大 时间不紧 对象状态少 要求输出“统计数据”}$的题目（可以看出，它并不只适用于仅有是非状态的题），而此时的正解有可能也较慢。</p>
<h2 id="2°爬山算法"><a href="#2°爬山算法" class="headerlink" title="2°爬山算法"></a>2°爬山算法</h2><p>严格意义上来讲，爬山算法的随机化过程很少。此处提到它仅仅是为了下方的模拟退火做铺垫。</p>
<p>看名字，这个算法的最基础应用就是求函数极值，即从当前点开始，每个点的值与相邻点的值比较，把指针挪至接近极值的那一个。</p>
<p>扔个图解，图片来源于网络。</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557488778286&di=baa6b0b13ca38563b89bb0a08ddacf43&imgtype=0&src=http%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_gif%2FFQd8gQcyN26rb6zJucxaycvJvllG32bxENtPZickocKIBfkSVSQia0noDUVtnicjC2PkIVy0S5ptuwhiafLZVKjK0A%2F640%3Fwx_fmt%3Dgif" alt></p>
<h2 id="3°模拟退火"><a href="#3°模拟退火" class="headerlink" title="3°模拟退火"></a>3°模拟退火</h2><p>概念此处仅简单讲解。如需详解请<a href="http://baidu.physton.com/?q=%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB" target="_blank" rel="noopener">下楼右转</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模拟退火（SA）</span><br><span class="line">模拟退火是基于物理中固体退火过程的随机化算法。它是一种通用算法，其主要操作是在冷却过程中按照Metropolis算法计算的概率随机跳出当前解。</span><br></pre></td></tr></table></figure>

<p>上面那块太长，换一个说法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">模拟退火就是进行多次循环，每次循环会以一个与当前答案正确度相关联的概率跳出当前域的算法。</span><br></pre></td></tr></table></figure>

<p>模拟退火的应用可谓是<code>远在天边，近在眼前</code>，你想用它时仿佛处处都是它，关键时刻你又常常想不到它。</p>
<p>作为一个随机化算法，模拟退火优于一般的随机，因为它不仅仅是像取随机数那样真正意义上的随机，而是在降温的过程中逐渐逼近答案，并且<code>偶尔地</code>出界探索更优解。</p>
<p>模拟退火比爬山就优秀在这里，模拟退火在温度较高时跳动概率大，而温度低时（逼近正解）跳动概率小。</p>
<p>因此模拟退火很大程度上改良了爬山算法会卡在一个小峰的尴尬弱点，也同时比乱序随机来得更准。</p>
<p>退火能够应用的范围很广。下至<a href="https://www.luogu.org/problem/P1049" target="_blank" rel="noopener">装箱问题</a>这样的01背包，上至<a href="https://www.luogu.org/problem/P2210" target="_blank" rel="noopener">Haywire</a>这样的难题（貌似没有平衡点难），都能见到它的身影，甚至在严谨的省选赛中SA也能占有一席之地(四川、江苏、河南、天津,etc)。</p>
<p>最后简单讲解一下模拟退火的实现，就以下图的求极值为例。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif" alt></p>
<p>第一步，定初温$\mathcal T$，不能太低（$1000^+$）。</p>
<p>第二步，定降温系数$\Delta$，一般在0.997，<del>有些题粗放到0.92也行</del>。</p>
<p>第三步，利用<a href="https://baike.baidu.com/item/Metropolis%E6%8E%A5%E5%8F%97%E5%87%86%E5%88%99/14678977" target="_blank" rel="noopener">metro_polis接受准则</a>产生当前温度能接受的随机值。</p>
<ul>
<li>关于metro_polis接受准则</li>
</ul>
<blockquote>
<p>若在温度T，当前状态i → 新状态j</p>
</blockquote>
<blockquote>
<p>若Ej&lt;Ei，则接受 j 为当前状态</p>
</blockquote>
<blockquote>
<p>否则，若概率 p大于[0,1)区间的随机数，则仍接受状态j为当前状态；若不成立，则保留状态i为当前状态。</p>
</blockquote>
<p>这个概率p的产生又是随机化的一大美学了：exp的巧用。</p>
<p><img src="https://i.loli.net/2019/08/04/htxTKI1jnqQwSfe.png" alt></p>
<p>图中我们可以看出，温度越高则跳出概率越高，温度越低则p也越低，即<code>p与T正相关</code>，且这个函数的值总是在[0,1)内，也就是说我们在这个区间内随便取数，比p小的概率就是p所代表的概率。</p>
<h2 id="4°数论中的随机化"><a href="#4°数论中的随机化" class="headerlink" title="4°数论中的随机化"></a>4°数论中的随机化</h2><p>判断素数一直是数论界的热门话题之一，如何高效地查找因数也是人们热衷的研究。</p>
<h3 id="1-从费马小定理说起"><a href="#1-从费马小定理说起" class="headerlink" title="1)从费马小定理说起"></a>1)从费马小定理说起</h3><blockquote>
<p>费马小定理</p>
</blockquote>
<blockquote>
<p>对于质数p和整数a，有$a^p$ ≡ a(mod p)。</p>
</blockquote>
<blockquote>
<p>这个结论大概率可以视作反之亦然（几乎充要）。</p>
</blockquote>
<blockquote>
<p>反推有$a^{p-1}$ ≡ 1(mod p)</p>
</blockquote>
<p>由上式我们可以得到费马测试的方案：</p>
<p>随机取多个整数a，对p进行同余测试，如果均通过则为质数。</p>
<p>但费马测试还是有小概率出错的，如下式</p>
<p>$2^{340}\ mod\ 341=1$显然成立</p>
<p>然而341是合数！对于341这样奇怪的反例，我们称为伪素数。</p>
<p>据研究，在1e12范围内共有5597个伪素数，这可不是小概率事件（出错率在0.00011，引自Matirx67的blog）。</p>
<h3 id="2-Miller-amp-Rabin"><a href="#2-Miller-amp-Rabin" class="headerlink" title="2)Miller&amp;Rabin"></a>2)Miller&amp;Rabin</h3><p>在发现这个bug以后，Miller和Rabin二人为费马测试的bug打上了补丁：<strong>二次探测定理</strong></p>
<p>按照上述，费马测试需要更换多个a，而二次探测定理则换了一个角度检查。</p>
<blockquote>
<p>如果p是奇素数，则 $x^2 ≡ 1(mod\ p)$的解为 $x ≡ 1$ 或 $x ≡ p - 1(mod\ p)$</p>
</blockquote>
<blockquote>
<p>——二次探测定理</p>
</blockquote>
<p>那么我们来手动模拟一下M_R的做法：</p>
<p>$I.$得到$a^{n-1} ≡ 1 (mod\ n)$</p>
<p>$II.$看指数n-1是否为偶，若为偶，则将其指数折半，用二次探测定理检查。</p>
<p>那我们回头看看上面的那组卡掉费马测试的数据：</p>
<p>$2^{340}\ mod\ 341=1$</p>
<p>我们得到式子后进行如下的操作：</p>
<p>$2^{170}\ mod\ 341=1$<code>二次探测也被突破？</code></p>
<p>那么再进行一次呢？</p>
<p>$2^{85}\ mod\ 341=32$</p>
<p>显然，341在第二次的二次探测定理下被排除。可见M_R也具有出错率，但可以通过多次探测缩小错误率。</p>
<ul>
<li>研究发现，M_R素数检测n次的错误率仅有($\frac{1}{4}$)$^n$，所以多来几次就好。</li>
</ul>
<h3 id="3-sf-rm-Pollard-Large-rho-（科普向）"><a href="#3-sf-rm-Pollard-Large-rho-（科普向）" class="headerlink" title="3)$\sf\rm\ Pollard_\Large\rho$（科普向）"></a>3)$\sf\rm\ Pollard_\Large\rho$（科普向）</h3><p>Pollard_rho，是当今最为优秀的随机化分解因数算法，由于其高效且随机，其模板是黑题，OI界也几乎用不到如此高效却复杂的因数分解算法。</p>
<p>下面简单介绍一下$\rho$的算法流程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第一步，先判断给出的数是否为素数。</span><br><span class="line">第二步，尝试找出一个数的因数（不一定是质数），并且除得对应的另一个因数。</span><br><span class="line">第三步，递归寻找每个因数的因数，直到整个数分解完毕。</span><br></pre></td></tr></table></figure>

<p>具体地，我们不会单纯地寻找一个数的因数，而是利用上了随机化的加持。</p>
<p>对于数n，假设要找的因数为t，我们先随机取一个$x_1$，再构造$x_2$，使条件$t|(x1-x2)$成立，并且条件$(x_1-x_2)|n$不成立（|:整除）。</p>
<p>此时有一个结论：若$gcd(x_1-x_2,n)$不为1，则该值为t。</p>
<p>如果值为1，则调整$x_2$使其再次符合条件（调整方式可以为$x_2=x_2*x_2+\phi$)（其中的$\phi$为随机值）。我们在调整的过程中如果出现了$x_1=x_2$的情况，则说明$x_1$选取不当，须重新选$x_1$。</p>
<p>pollard发现，在调整$x_1$的过程中，$x_1$与$x_2$最终会形成$\huge\rho$循环。</p>
<p><img src="https://i.loli.net/2019/08/05/oe3mv7bUIXz2yQP.png" alt></p>
<p>计算出因数后只需要判断下是否为质数就行了，此处就要引进上文的M_R判素法了。</p>
<h2 id="5°随机化的其他运用"><a href="#5°随机化的其他运用" class="headerlink" title="5°随机化的其他运用"></a>5°随机化的其他运用</h2><p>随机化在很多不起眼的地方也起着巨大的作用，看上去傻乎乎的决策却也有着猴子打字写出成书的可能。</p>
<p>或许随机化不能称为优化，有人甚至认为它是劣化，但不得不说的一点是：<code>没有人能卡掉随机优化</code>，除了坏运气。</p>
<h3 id="1-spfa？"><a href="#1-spfa？" class="headerlink" title="1)spfa？"></a>1)spfa？</h3><p>众所周知，spfa有个双端队列优化，那么到底把新来的点放队头还是队尾呢？<code>rand()%2</code>就是这样的01决策的利器。</p>
<h3 id="2-排序？"><a href="#2-排序？" class="headerlink" title="2)排序？"></a>2)排序？</h3><blockquote>
<p>真的，真的请各位不要再嘲笑random_shuffle了</p>
</blockquote>
<blockquote>
<p>——fst</p>
</blockquote>
<p>什么？比$O(NlogN)$更猛？（应该不会快过桶排）</p>
<p>对于随机化排序，我只能说：这是可能发生的。</p>
<p>因为对于一串相当有序的序列，随机化的效率还是很出色的。</p>
<p>引用<code>平凡的幸福</code>的一次测试结果，</p>
<p><img src="https://i.loli.net/2019/08/04/4xpnNXb2efE8Y7F.png" alt></p>
<p>此处的所有数据均为随机产生，不具有有序性。</p>
<ul>
<li>经在下测试，对于1e5的较有序数据，随机排序的效率最高可达快排的1.2倍！</li>
</ul>
<h1 id="3-一些细节"><a href="#3-一些细节" class="headerlink" title="3.一些细节"></a>3.一些细节</h1><ul>
<li><p>随机化的时候，一定要考虑好数据的大小，如果能够估计出正解复杂度更好（谁会知道正解还写随机QwQ），如果正解是搜索一类的较暴力的算法，且具有01决策性或是一些别致的可随机的提示，则可以用随机化加以解决。</p>
</li>
<li><p>随机化很重要的一点是：循环的次数一定要多，在上面的例子中，我们可以发现一个较为稳定的随机化算法一定是有一定准则的，并且往往需要多次取优处理。</p>
</li>
<li><p>在省选以下的比赛中，尽量不要考虑使用随机化，因为随机严格意义上不属于考纲。</p>
</li>
<li><p>随机化程序好写，但是千万不能让随机成为定式，它永远只是备胎，一定要有十分把握（无论是此题爆零把握还是已知正解把握），否则随机化会用运气来压制你的分数。</p>
</li>
</ul>
<h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h1><p>随机化很美，不是么？</p>
<p>它似算法，却又非算法；</p>
<p>它永不是正解，有时却可以爆踩std。</p>
<p>随机化，就像生活，你还来不及做选择，就已经被随机地剪去了通往平行宇宙的枝；</p>
<p>随机化，不像生活，它可以一次次地重来，直到让你满意，而这却只存在于《奇异博士》中。</p>
<p>随机化，像极了爱情，一次次的01决策令人昏了头，却又陶醉其中；</p>
<p>随机化，又不像爱情，因为生活里，没有哪一个备胎会像它那样，静静地坐在你的脑海深处——</p>
<p>你想与不想，它总在那里，不曾离去。</p>
<p>有人说，选择非儿戏。</p>
<p>我说，随机，美得不像儿戏，而像世界。</p>
<p>游戏的魅力，不正在于胜负的随机性么？有胜有负才是最美。</p>
<p>失败的苦痛，不正在于随机么？</p>
<p>毕竟胜败这种非黑即白的东西，</p>
<p>运气总喜欢插手。</p>
<hr>
<p>$\Huge\mathcal T$ $\Huge\mathcal h$ $\Huge\mathcal e$ $\ $ $\ $ $\Huge\mathcal E$ $\Huge\mathcal n$ $\Huge\mathcal d$</p>
]]></content>
      <categories>
        <category>随机化</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>退役小记</title>
    <url>/2019/11/23/%E9%80%80%E5%BD%B9%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>七百余题血与泪，初赛退役一场空。<br>今朝信竞今朝傲，留待迟暮望斜阳。</p><p>有缘再会吧，@first_fan!<br>OI,我们THU,再见！</p><p><img src="https://www.gushixuexi.com/wp-content/uploads/2016/11/4-95.jpg" alt></p>]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟退火解背包</title>
    <url>/2019/11/23/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E8%A7%A3%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h3 id="本文所包含的思路来自于NCC79601"><a href="#本文所包含的思路来自于NCC79601" class="headerlink" title="本文所包含的思路来自于NCC79601"></a>本文所包含的思路来自于<a href="https://ncc79601.blog.luogu.org/solution-p1049" target="_blank" rel="noopener">NCC79601</a></h3><h1 id="算法剖析"><a href="#算法剖析" class="headerlink" title="* 算法剖析"></a>* 算法剖析</h1><p> 简单来讲，背包退火就是用模拟退火的思路解决某些类型的背包问题，继承了模拟退火的<strong>玄学复杂度</strong>，<em><del>也继承了它的不稳定性</del>_，所以能够有效地解决大背包问题的TLE问题。这个算法能够把数十行的代码优化部分转移为 _<del>洗把脸</del></em> 调参的问题。</p><h1 id="例题-：LuoGuP1049【装箱问题】"><a href="#例题-：LuoGuP1049【装箱问题】" class="headerlink" title="例题 ：LuoGuP1049【装箱问题】"></a><em>例题 ：LuoGuP1049【装箱问题】</em></h1><a id="more"></a>
<h1 id="有一个箱子容量为V，同时有n个物品，每个物品有一个体积vi。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。"><a href="#有一个箱子容量为V，同时有n个物品，每个物品有一个体积vi。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。" class="headerlink" title="有一个箱子容量为V，同时有n个物品，每个物品有一个体积vi。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。"></a>有一个箱子容量为V，同时有n个物品，每个物品有一个体积vi。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</h1><h1 id="·算法过程"><a href="#·算法过程" class="headerlink" title="·算法过程"></a>·<em>算法过程</em></h1><h2 id="首先就是模拟退火的随机设置自然就是把随机数种子设置好，别忘了先洗脸，然后通过模拟退火原理设置好转移概率表达式"><a href="#首先就是模拟退火的随机设置自然就是把随机数种子设置好，别忘了先洗脸，然后通过模拟退火原理设置好转移概率表达式" class="headerlink" title="首先就是模拟退火的随机设置自然就是把随机数种子设置好，别忘了先洗脸，然后通过模拟退火原理设置好转移概率表达式:"></a>首先就是模拟退火的随机设置自然就是把随机数种子设置好，<del>别忘了先洗脸</del>，然后通过模拟退火原理设置好转移概率表达式:</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool accept(int del)</span><br><span class="line">&#123;</span><br><span class="line">    return ((del&gt;0)||exp(-del/T) &gt; (double)rand()/RAND_MAX);</span><br><span class="line">&#125; //转移概率表达式</span><br></pre></td></tr></table></figure>
<h2 id="然鹅蒟蒻的我很难解释清楚为什么随着T的减小他接受更劣解的概率会越来越小，只知道利用这个概率是e-dE-kT）。"><a href="#然鹅蒟蒻的我很难解释清楚为什么随着T的减小他接受更劣解的概率会越来越小，只知道利用这个概率是e-dE-kT）。" class="headerlink" title="然鹅蒟蒻的我很难解释清楚为什么随着T的减小他接受更劣解的概率会越来越小，只知道利用这个概率是e^(-dE/kT）。"></a>然鹅蒟蒻的我很难解释清楚为什么随着T的减小他接受更劣解的概率会越来越小，只知道利用这个概率是e^(-dE/kT）。</h2><h3 id="使用这个概率从而达到刚开始退火，跳出当前最优解的概率大，而当靠近答案时跳出正确答案的可能性又逐渐减小。如有不懂请挪步模拟退火详解"><a href="#使用这个概率从而达到刚开始退火，跳出当前最优解的概率大，而当靠近答案时跳出正确答案的可能性又逐渐减小。如有不懂请挪步模拟退火详解" class="headerlink" title="使用这个概率从而达到刚开始退火，跳出当前最优解的概率大，而当靠近答案时跳出正确答案的可能性又逐渐减小。如有不懂请挪步模拟退火详解"></a>使用这个概率从而达到刚开始退火，跳出当前最优解的概率大，而当靠近答案时跳出正确答案的可能性又逐渐减小。如有不懂请挪步<a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html" target="_blank" rel="noopener">模拟退火详解</a></h3><h1 id="·偏移过程"><a href="#·偏移过程" class="headerlink" title="·偏移过程"></a>·<em>偏移过程</em></h1><h2 id="这就是上述问题的用武之地了-以一定的概率不选当前最优解中的那个物品，从而衍生出另一种方案，如果比刚刚的更好，那么说明运气很好，跳到了一个更优解范围附近"><a href="#这就是上述问题的用武之地了-以一定的概率不选当前最优解中的那个物品，从而衍生出另一种方案，如果比刚刚的更好，那么说明运气很好，跳到了一个更优解范围附近" class="headerlink" title="这就是上述问题的用武之地了:以一定的概率不选当前最优解中的那个物品，从而衍生出另一种方案，如果比刚刚的更好，那么说明运气很好，跳到了一个更优解范围附近"></a>这就是上述问题的用武之地了:以一定的概率不选当前最优解中的那个物品，从而衍生出另一种方案，如果比刚刚的更好，那么说明运气很好，跳到了一个更优解范围附近</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(accept(dE)) </span><br><span class="line">		&#123;//以上述概率发生转移</span><br><span class="line">            if(vis[a])</span><br><span class="line">			&#123;</span><br><span class="line">                vis[a] = false;</span><br><span class="line">                tot -= v[a];</span><br><span class="line">            &#125;//在当前物品已选的情况下放弃选用当前物品</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">                if(tot + v[a] &gt; V)</span><br><span class="line">				&#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">                vis[a] = true;</span><br><span class="line">                tot += v[a];</span><br><span class="line">            &#125;//在当前物品未选的情况下尝试选用当前物品</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="·退火步骤"><a href="#·退火步骤" class="headerlink" title="·退火步骤"></a>·退火步骤</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(T &gt; 1e-14) &#123;</span><br><span class="line">        ans=max(ans,tot); //维护最优答案，以防非酋情况发生</span><br><span class="line">        a = rd; //进行随机</span><br><span class="line">        int dE = v[a];</span><br><span class="line">        if(vis[a])</span><br><span class="line">		&#123;</span><br><span class="line">			dE *= -1; //产生能量差</span><br><span class="line">		&#125;</span><br><span class="line">        if(accept(dE)) </span><br><span class="line">		&#123;//发生转移</span><br><span class="line">            if(vis[a])</span><br><span class="line">			&#123;</span><br><span class="line">                vis[a] = false;</span><br><span class="line">                tot -= v[a];</span><br><span class="line">            &#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">                if(tot + v[a] &gt; V)</span><br><span class="line">				&#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">                vis[a] = true;</span><br><span class="line">                tot += v[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T *= delta; //降温</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="该过程通过降温系数delta对初温为T的物体降温，直到物体温度冷却接近0。但是不能直接将tot作为答案输出，否则没洗脸的话可能会出现跳到了较劣解的情况。"><a href="#该过程通过降温系数delta对初温为T的物体降温，直到物体温度冷却接近0。但是不能直接将tot作为答案输出，否则没洗脸的话可能会出现跳到了较劣解的情况。" class="headerlink" title="该过程通过降温系数delta对初温为T的物体降温，直到物体温度冷却接近0。但是不能直接将tot作为答案输出，否则没洗脸的话可能会出现跳到了较劣解的情况。"></a>该过程通过降温系数delta对初温为T的物体降温，直到物体温度冷却接近0。但是不能直接将tot作为答案输出，否则<del>没洗脸的话</del>可能会出现跳到了较劣解的情况。</h2><h1 id="退火的一些小技巧"><a href="#退火的一些小技巧" class="headerlink" title="退火的一些小技巧"></a>退火的一些小技巧</h1><h3 id="1-降温系数用0-99789（玄学参数）"><a href="#1-降温系数用0-99789（玄学参数）" class="headerlink" title="1. 降温系数用0.99789（玄学参数）"></a>1. 降温系数用0.99789（玄学参数）</h3><h3 id="2-初温设置为1926（玄学参数）"><a href="#2-初温设置为1926（玄学参数）" class="headerlink" title="2. 初温设置为1926（玄学参数）"></a>2. 初温设置为1926（玄学参数）</h3><h3 id="3-退火的转移概率计算式-e-dE-kT）"><a href="#3-退火的转移概率计算式-e-dE-kT）" class="headerlink" title="3. 退火的转移概率计算式:e^(-dE/kT）"></a>3. 退火的转移概率计算式:e^(-dE/kT）</h3><h3 id="del-gt-0-exp-del-T-gt-double-rand-RAND-MAX"><a href="#del-gt-0-exp-del-T-gt-double-rand-RAND-MAX" class="headerlink" title="(del&gt;0)||exp(-del/T) &gt; (double)rand()/RAND_MAX"></a>(del&gt;0)||exp(-del/T) &gt; (double)rand()/RAND_MAX</h3><h3 id="4-最低温不要调的太低，不然妥妥的TLE"><a href="#4-最低温不要调的太低，不然妥妥的TLE" class="headerlink" title="4.最低温不要调的太低，不然妥妥的TLE"></a>4.最低温不要调的太低，不然妥妥的TLE</h3><h3 id="5-交一次不行说明rp不够你的时间不好，原代码再交一次也许-就行了呢"><a href="#5-交一次不行说明rp不够你的时间不好，原代码再交一次也许-就行了呢" class="headerlink" title="5.交一次不行说明rp不够你的时间不好，原代码再交一次也许 就行了呢"></a>5.交一次不行说明<del>rp不够</del>你的时间不好，原代码再交一次也许 就行了呢</h3><h3 id="6-别忘了洗脸rp"><a href="#6-别忘了洗脸rp" class="headerlink" title="6.别忘了洗脸rp++"></a><del>6.别忘了洗脸rp++</del></h3><h1 id="番外篇-论欧皇的养成"><a href="#番外篇-论欧皇的养成" class="headerlink" title="番外篇:论欧皇的养成"></a>番外篇:论欧皇的养成</h1><p>iewqufhiwefdiweduiqwediuqedwedjewui</p>
<h3 id="被某个非酋网友摁在键盘上打-笑哭"><a href="#被某个非酋网友摁在键盘上打-笑哭" class="headerlink" title="(被某个非酋网友摁在键盘上打/笑哭)"></a>(被某个非酋网友摁在键盘上打/笑哭)</h3><p><img src="https://i.postimg.cc/Gpw8rX42/yls.png" alt></p>
<h1 id="这是某个没洗脸的基佬的↑"><a href="#这是某个没洗脸的基佬的↑" class="headerlink" title="这是某个没洗脸的基佬的↑"></a>这是某个没洗脸的基佬的↑</h1><h1 id="这是我的↓"><a href="#这是我的↓" class="headerlink" title="这是我的↓"></a>这是我的↓</h1><p><img src="https://i.postimg.cc/05TCX1vM/fst.png" alt></p>
<h2 id="溜了溜了……"><a href="#溜了溜了……" class="headerlink" title="溜了溜了……"></a>溜了溜了……</h2>]]></content>
      <categories>
        <category>随机化</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合小记</title>
    <url>/2019/11/23/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说回来，花了一个下午把练习册上几十页排列组合的题都做了的感觉还挺良好的呐……</p><p>毕竟是前OI选手，这种题秒不掉就有点淼了QAQ.</p><p>这里留下一些零碎的思想吧。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>在开始以前，为了方便描述，我们先给出几个定义：</p><ul>
<li><p>方案数用$N$表示</p>
</li>
<li><p>第i个子问题的方案数用$N_i$表示</p>
</li>
<li><p>排列，组合符号为$A$,$C$</p>
</li>
</ul><a id="more"></a>




<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>排列组合是组合数学中的基础。排列就是指从给定个数的元素中取出指定个数的元素进行排序；组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。</p>
<ul>
<li><p>排列： $\large\mathrm A_n^m =\frac{n!}{(n - m)!}$</p>
</li>
<li><p>组合：$\large\mathrm C_n^m = \frac{n!}{m!(n - m)!}$</p>
</li>
<li><p>加法原理：一件事有n类方法，第i类有$m_i$种方法，则方案数为：$N=m_1+m_2+…+m_n$</p>
</li>
<li><p>乘法原理：一件事必须经过n个步骤，第i步有$m_i$种方法，则方案数为：$N=m_1·m_2·…·m_n$</p>
</li>
</ul>
<h2 id="方法整理"><a href="#方法整理" class="headerlink" title="方法整理"></a>方法整理</h2><h3 id="插空法"><a href="#插空法" class="headerlink" title="插空法"></a>插空法</h3><p>插空法，主要用于解决含有“不相邻”要求的问题。主要思想分为两步：将无要求的部分进行排列，假设长为L；在序列的L+1个间隙中插入特殊元素，插入第一个时有L+1种，第二个L种，以此类推。</p>
<p>$P1.$有a个同学，b个老师站成一排，要求老师站位不相邻，问方案数。</p>
<p>第一步，使用排列公式完成同学的排列：</p>
<p>$N_1=A^a_a=a!$</p>
<p>那么我们得到了这样的同学序列：</p>
<p>$↓a_{i_1}↓a_{i_2}↓a_{i_3}↓……$</p>
<p>可以看见↓的部位是可以插入老师的，一共有a+1个</p>
<p>第二步，a+1个空格中插入b个老师（此处默认有解）</p>
<p>$N_2=(a+1)·a·(a-1)···(a+2-b)=A^b_{a+1}$</p>
<p>第三步，乘法原理得解</p>
<p>$N=N_1·N_2=A^a_a·A^b_{a+1}$</p>
<blockquote>
<p>备注：有时候，插空会要求不能选取两端的空，即只有a-1个空，稍作变化即可。</p>
</blockquote>
<h3 id="捆绑法"><a href="#捆绑法" class="headerlink" title="捆绑法"></a>捆绑法</h3><p>捆绑法，主要用于解决含有“必须相邻”要求的问题。主要思想分两步：将需要相邻的部分进行“捆绑”，并内部求排列；将捆绑物视作一个物品放回原问题，求排列即可。</p>
<p>$P2.$有a个同学，b个老师站一排，要求所有老师站位连续，问方案数。</p>
<p>第一步，把所有老师做排列：</p>
<p>$N_1=A^b_b$</p>
<p>随后我们就可以把这个长为b的序列当作一个整体来操作了。</p>
<p>第二步，将“老师”作为一个同学和其他同学进行排列：</p>
<p>$N_2=A^{a+1}_{a+1}$</p>
<p>第三步，对于每个学生排列，对老师排列进行乘法原理：</p>
<p>$N=N_1·N_2=A^b_b·A^{a+1}_{a+1}$</p>
<blockquote>
<p>备注：捆绑的思想运用很广泛，其实就是分治的基础：把问题拆分为两个子问题分步完成。</p>
</blockquote>
<h3 id="隔板法"><a href="#隔板法" class="headerlink" title="隔板法"></a>隔板法</h3><p>隔板法，用于解决划分集合问题。其主要思想是把划分集合问题改为“插入隔板”问题，从而转化为插入法解决掉。</p>
<p>$P3.$有a个相同的糖，分给b个人，每个人至少有c颗糖，问方案数。</p>
<p>第一步，把棘手的c处理成1，即每人至少一颗。</p>
<p>我们可以预先给每个人都发c-1颗糖，总数减少b*(c-1)即可：</p>
<p>$a’=a-b·(c-1)$</p>
<p>第二步，观察到我们要把a’个糖分给b个人，我们进行转化性思考：</p>
<p>a’颗糖摆成一排，我们用b-1个隔板进行分割，则恰好可以得到b份。</p>
<p>于是问题就转化成了向a’-1个间隙插入b-1个隔板，组合即可：</p>
<p>$N=C^{b-1}_{a’-1}$</p>
<blockquote>
<p>备注：上面就是要用到一百次的隔板法公式，死记也要记住。</p>
</blockquote>
<h3 id="剩余法"><a href="#剩余法" class="headerlink" title="剩余法"></a>剩余法</h3><p>剩余法，利用到了<code>正难则反</code>的思想，即如果让我们从中选择凑数，我们可以反向思维，全选然后删数。这种方法会在目标数接近总值时极为有效。</p>
<p>$P4.$背包里有23个价值为5的物品，有10个价值为10的物品，物品两两不同，问取出价值200的物品的方案数。</p>
<p>试图正面求解，发现正面凑数过于复杂，所以考虑到剩余法。</p>
<p>计算出全选总值为215，我们就全部选上。</p>
<p>问题就转化为选出若干个物品不带，使得它们的和为15即可。</p>
<p>15就只有两类凑法：10+5，5+5+5。</p>
<p>根据加法原理：</p>
<p>$N=C_{23}^{3}+C_{23}^{1}·C_{10}^{1}$</p>
<blockquote>
<p>备注：正难则反是一种很巧妙的思路，带在身上总是好的。</p>
</blockquote>
<h3 id="反向法"><a href="#反向法" class="headerlink" title="反向法"></a>反向法</h3><p>反向法，同样利用了正难则反的思想，但是上个方法中，我们是从问题本身反向的，此处所讲的方法则是从求方案数的方面反向：求不满足条件的方案数。</p>
<p>$P5.$从n个人中选m个人出来，问指定的p个人中至少有一人在其中的方案数。</p>
<p>此类问题往往可以正面解出，如本题中我们可以通过讨论这p个人是否在其中并且进行容斥求解，但是显然较为麻烦。</p>
<p>随后考虑到“至少有一人在其中”的否定是“没有一个人在其中”，于是可以进行反向求解：<code>p个人都不被选中的方案数</code>，再用总方案数作差即可。</p>
<p>利用组合求总方案数：</p>
<p>$N_1=C_n^m$</p>
<p>计算去掉这p个人的组合数，即条件不成立的方案数：</p>
<p>$N_2=C^{m}_{n-p}$</p>
<p>作差得解：</p>
<p>$N=N_1-N_2=C^m_n-C_{n-p}^m$</p>
<blockquote>
<p>备注：反向法可能与正解复杂度相同，而且大概率需要结合容斥法计算，务必谨慎使用。</p>
</blockquote>
<h3 id="容斥法"><a href="#容斥法" class="headerlink" title="容斥法"></a>容斥法</h3><p>容斥法，往往用于解决对于多个个体有要求，并且多个要求可能同时成立的问题。在这时，如果我们简单地对于每个独立的要求，把符合要求的方案数简单加和，会发现同时满足条件的方案被屡次计算，此处就可以用简单容斥思想解决条件交集问题。</p>
<p>$P6.$对n个人进行排列，其中甲和丙，乙和丙均不能相邻，问方案数</p>
<p>容斥法往往可以结合反向法使用，此处就是一个典型的例子：我们求解让不能相邻的相邻的方案数。</p>
<p>所有的方案数：</p>
<p>$N_1=A^n_n$</p>
<p>通过捆绑法，甲丙，乙丙相邻的方案数均为：</p>
<p>$N_2=A^2_2·A^{n-1}_{n-1}$</p>
<p>甲丙，乙丙同时相邻的方案数：</p>
<p>$N_3=2*A^{n-2}_{n-2}$</p>
<p>通过容斥原理，不符合的方案数为：</p>
<p>$N_4=N_2+N_2-N_3$</p>
<p>那么符合条件的方案数就是：</p>
<p>$N=N_1-N_4$</p>
<blockquote>
<p>备注：容斥法常常是作为辅助方法进行计算，也是题目的坑点难点所在，千万注意讨论重叠条件部分的方案数。</p>
</blockquote>
<h3 id="分块假设法"><a href="#分块假设法" class="headerlink" title="分块假设法"></a>分块假设法</h3><p>分块假设法，常常用于多块染色问题，此类问题的难点在于元素之间的牵制关系往往过多，用上述方法很难求解，而枚举又容易出错。分块假设法则是将多个元素整合成一块，讨论一个块的“外交关系”，如此将多块图的块数减少，再对于每一种假设在整合块内讨论+乘法原理得解。</p>
<p>$P7.$现有四棱锥S-ABCD，其中ABCD为底面，用四种颜色给5个顶点分别上色，使得每条棱两端点颜色不同，问方案数。</p>
<p><img src="https://i.loli.net/2019/12/01/OsRV1hJnF9drgcE.png" alt></p>
<p>第一眼看到立体染色，我们首先想到的问题是：有没有办法<strong>降维</strong>？<code>答案是有的</code>。</p>
<p><img src="https://i.loli.net/2019/12/01/k3YEQd1gHeGybUA.png" alt></p>
<p>俯视图可见就是一个<strong>四分环套圆</strong>模型，把降维的图作出来：</p>
<p><img src="https://i.loli.net/2019/12/01/O3kNo9yKHPwB7F1.png" alt></p>
<p>那么我们进行分块假设法解决此类问题：</p>
<p>第一步，将SAB分为一块，讨论该块的可能数：</p>
<p>$N_1=A_4^3$</p>
<p>第二步，对于某一种SAB讨论CD。不妨设S、A、B分别占用了1、2、3的颜色，那么若C上3的颜色，则D可以上2、4的颜色；若C上4的颜色，则D只能上2的颜色。</p>
<p>$N_2=2+1=3$</p>
<p>第三步，对于每种SAB，都有3种CD，则乘法原理：</p>
<p>$N=N_1·N_2=72$</p>
<blockquote>
<p>备注：分块假设法可以大幅降低讨论情况数，但是在外交情况较为复杂的时候会显得难以讨论。</p>
</blockquote>
<h2 id="染色问题专题"><a href="#染色问题专题" class="headerlink" title="染色问题专题"></a>染色问题专题</h2>]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>悬线法</title>
    <url>/2019/11/23/%E6%82%AC%E7%BA%BF%E6%B3%95/</url>
    <content><![CDATA[<p>悬线法，这个名词是我在做<a href="https://www.luogu.org/problem/P4147" target="_blank" rel="noopener">P4147 玉蟾宫</a>时遇到的。</p><p>此题题目大概意思：计算01矩阵内最大的全0矩形面积。</p><p>本题自然是可以用单调栈做的了，此处不做赘述。重点讲下<strong>悬线法</strong>。</p><p>如果矩阵是n$<em>$m，则悬线法的时间复杂度最差情况是O($n</em>m$)。</p><p>其大致原理如下：</p><p>$\sf\color{darkviolet}{\text{悬线：指一条上端点覆盖了一个障碍点或与矩阵边界重合，且除端点外，不覆盖任何障碍点的竖线}}$</p><a id="more"></a>





<p>$\sf\color{lime}{\text{几个关键字：以上界或某个障碍点作为上端点，除端点不覆盖任何障碍点，竖线。}}$</p>
<p>所以就有了模糊的想法：<strong>以一条悬线左右平移直到遇到障碍点，直到其某个瞬间无法保持悬线定义为止。过程中扫过的矩形中必定包含了所求矩形。</strong></p>
<p>则我们可以通过枚举悬线的下端点，进而枚举到悬线。下端点的数量不会超过n*m，而P4147这道题恰好是较密的障碍分布，所以枚举这步就已经达到了时限，试图O(1)完成直线的平移操作。</p>
<p>O(1)的实现方法很单调：要么套非递推公式算，要么记信息用。此处我们以空间换时间，采用后者的<strong>记</strong>的方式。</p>
<p>对于一个悬线，其平移方式无非两种：左右。但悬线在某些条件下是可以乡下继续延伸的，自然能伸则伸，无需记录。为了记录并比较矩形面积，继续引入悬线的高。</p>
<p>$\sf\color{lime}{\text{所以对于一个以点(i,j)为下端点的悬线，目前我们要记的有三样：}}$</p>
<p>$\sf\color{red}{\text{延伸左界l[i][j]，延伸右界r[i][j]，高度h[i][j]}}$</p>
<p>那么我们充分利用之前信息，保证在O(n*m)时间内通过递推得到三个值即可。</p>
<p>递推的初始条件比较显然：高度为1的可以左右一直延伸到左右界，l,r,h均可知。</p>
<p>初始条件有了，怎么递推？</p>
<h3 id="mathcal-h-i-j-h-i-1-j-1-以行数i为底的高度势必比i-1的高1。"><a href="#mathcal-h-i-j-h-i-1-j-1-以行数i为底的高度势必比i-1的高1。" class="headerlink" title="$\mathcal h[i][j]=h[i-1][j]+1$ 以行数i为底的高度势必比i-1的高1。"></a>$\mathcal h[i][j]=h[i-1][j]+1$ 以行数i为底的高度势必比i-1的高1。</h3><h3 id="mathcal-l-i-j-max-l-i-j-l-i-1-j-向左延伸，一定要将就靠右的才符合条件。"><a href="#mathcal-l-i-j-max-l-i-j-l-i-1-j-向左延伸，一定要将就靠右的才符合条件。" class="headerlink" title="$\mathcal l[i][j]=max(l[i][j],l[i-1][j])$ 向左延伸，一定要将就靠右的才符合条件。"></a>$\mathcal l[i][j]=max(l[i][j],l[i-1][j])$ 向左延伸，一定要将就靠右的才符合条件。</h3><h3 id="mathcal-r-i-j-min-r-i-j-r-i-1-j-向右延伸，一定要将就靠左的才符合条件。"><a href="#mathcal-r-i-j-min-r-i-j-r-i-1-j-向右延伸，一定要将就靠左的才符合条件。" class="headerlink" title="$\mathcal r[i][j]=min(r[i][j],r[i-1][j])$ 向右延伸，一定要将就靠左的才符合条件。"></a>$\mathcal r[i][j]=min(r[i][j],r[i-1][j])$ 向右延伸，一定要将就靠左的才符合条件。</h3><p>信息有了，对于每条悬线，计算面积用时就是O(1)的。</p>
<h3 id="mathcal-S-r-i-j-l-i-j-h-i-j-，浅显易懂。"><a href="#mathcal-S-r-i-j-l-i-j-h-i-j-，浅显易懂。" class="headerlink" title="$\mathcal {S=(r[i][j]-l[i][j])*h[i][j]}$，浅显易懂。"></a>$\mathcal {S=(r[i][j]-l[i][j])*h[i][j]}$，浅显易懂。</h3><p>最终，最坏时间复杂度归于O(n*m)，在稀疏障碍图中，由于下端点数量不多，该算法效率极高。</p>
<p>以下是P4147的关键代码部分:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化部分</span></span><br><span class="line"><span class="keyword">for</span>(ri i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(ri j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			rd:</span><br><span class="line">			c=getchar();</span><br><span class="line">			<span class="keyword">if</span>(c!=<span class="string">'F'</span>&amp;&amp;c!=<span class="string">'R'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> rd;</span><br><span class="line">			&#125;</span><br><span class="line">			v[i][j]=(c==<span class="string">'F'</span>);<span class="comment">//F for 1 &amp; R for 0</span></span><br><span class="line">			l[i][j]=j;</span><br><span class="line">			r[i][j]=j;</span><br><span class="line">			h[i][j]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//转移部分</span></span><br><span class="line"><span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(ri j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;v[i][j]&amp;&amp;v[i<span class="number">-1</span>][j])</span><br><span class="line">			&#123;</span><br><span class="line">				r[i][j]=min(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">				l[i][j]=max(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">				h[i][j]=h[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans=max(ans,(r[i][j]-l[i][j]+<span class="number">1</span>)*h[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<ul>
<li>#1 <a href="https://www.luogu.org/problem/P4147" target="_blank" rel="noopener">P4147 玉蟾宫</a>$\sf\color{lime}{[O]}$</li>
<li>#2 <a href="https://www.luogu.org/problemnew/show/P1578" target="_blank" rel="noopener">P1578 奶牛浴场</a></li>
<li>#3 <a href="https://www.luogu.org/problem/P1169" target="_blank" rel="noopener">P1169 棋盘制作</a>$\sf\color{lime}{[O]}$</li>
</ul>
<p>笔者注：对于奶牛浴场这种数组存不下的题，要记得灵活应变，不能直接套用格式。</p>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>一个并不全的提高组算法模板大全</title>
    <url>/2019/11/23/%E5%B9%B6%E4%B8%8D%E5%85%A8%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">KMP字符串匹配</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 1000000 + 5&gt; f &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFail</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; P.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> j = f[i];</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; P[i] != P[j])</span><br><span class="line">		&#123;</span><br><span class="line">			j = f[j];</span><br><span class="line">		&#125;</span><br><span class="line">		f[i + <span class="number">1</span>] = P[i] == P[j] ? j + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;T, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GetFail(P);</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; T.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; P[j] != T[i])</span><br><span class="line">		&#123;</span><br><span class="line">			j = f[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (P[j] == T[i])</span><br><span class="line">		&#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == P.size())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i - P.size() + <span class="number">2</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> T, P;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">	Find(P, T);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt;= T.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AC自动机 by yls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trie树是一棵26叉树,从不同的位置开始建新点;</span></span><br><span class="line"><span class="comment">//AC自动机 : trie树上的类似KMP;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> c[<span class="number">1000</span>],s;<span class="comment">//模式串,文本串;</span></span><br><span class="line"><span class="keyword">int</span> maxv,ni;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">1000001</span>];<span class="comment">//文本串末编号,方便记录答案;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fail,rec;<span class="comment">//fail指针,模式串出现次数;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span>(ch));</span><br><span class="line">    	fail=rec=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;tree[<span class="number">1000001</span>];<span class="comment">//0层表示根;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'-'</span>)&#123;f=<span class="number">-1</span>;&#125;ch=getchar();</span><br><span class="line">    &#125;<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();</span><br><span class="line">    &#125;<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=c[id].length(),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=c[id][i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].ch[p]==<span class="number">0</span>)&#123;</span><br><span class="line">        	tree[now].ch[p]=++ni;</span><br><span class="line">        &#125;now=tree[now].ch[p];<span class="comment">//加点;</span></span><br><span class="line">    &#125;tree[now].rec++;pos[id]=now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AC自动机之所以能实现多模式匹配,就归功于Fail指针的建立.</span></span><br><span class="line"><span class="comment">//当前节点t有fail指针,其fail指针所指向的节点和t所代表的字符是相同的.</span></span><br><span class="line"><span class="comment">//因为t匹配成功后,我们需要去匹配t-&gt;child,发现失配,那么就从t-&gt;fail这个节点开始再次去进行匹配.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Fail指针的求法：</span></span><br><span class="line"><span class="comment">//Fail指针用BFS来求得,对于直接与根节点相连的节点来说,如果这些节点失配,他们的Fail指针直接指向root即可,</span></span><br><span class="line"><span class="comment">//其他节点其Fail指针求法如下：</span></span><br><span class="line"><span class="comment">//假设当前节点为father,其孩子节点记为child.求child的Fail指针时,首先我们要找到其father的Fail指针所指向的节点,</span></span><br><span class="line"><span class="comment">//假如是t的话,我们就要看t的孩子中有没有和child节点所表示的字母相同的节点,</span></span><br><span class="line"><span class="comment">//如果有的话,这个节点就是child的fail指针,</span></span><br><span class="line"><span class="comment">//如果发现没有,则需要找father-&gt;fail-&gt;fail这个节点,然后重复上面过程,</span></span><br><span class="line"><span class="comment">//如果一直找都找不到,则child的Fail指针就要指向root.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[now].ch[i])&#123;q.push(tree[now].ch[i]);&#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now=q.front();q.pop();</span><br><span class="line">        <span class="keyword">int</span> f=tree[now].fail;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[now].ch[i])&#123;</span><br><span class="line">                <span class="comment">//while(f&amp;&amp;tree[f].ch[i]==0)&#123;f=tree[f].fail;&#125;//上跳找到fail; </span></span><br><span class="line">                tree[tree[now].ch[i]].fail=tree[f].ch[i];</span><br><span class="line">                q.push(tree[now].ch[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;tree[now].ch[i]=tree[f].ch[i];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本串的匹配</span></span><br><span class="line"><span class="comment">//匹配过程分两种情况：</span></span><br><span class="line"><span class="comment">//(1)当前字符匹配,表示从当前节点沿着树边有一条路径可以到达目标字符,</span></span><br><span class="line"><span class="comment">//如果当前匹配的字符是一个单词的结尾,我们可以沿着当前字符的fail指针,一直遍历到根,</span></span><br><span class="line"><span class="comment">//如果这些节点末尾有标记(此处标记代表节点是一个单词末尾的标记),这些节点全都是可以匹配上的节点.</span></span><br><span class="line"><span class="comment">//我们统计完毕后,并将那些节点标记.</span></span><br><span class="line"><span class="comment">//此时只需沿该路径走向下一个节点继续匹配即可,目标字符串指针移向下个字符继续匹配;</span></span><br><span class="line"><span class="comment">//(2)当前字符不匹配,则去当前节点失败指针所指向的字符继续匹配,匹配过程随着指针指向root结束.</span></span><br><span class="line"><span class="comment">//重复这2个过程中的任意一个,直到模式串走到结尾为止.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.length(),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ch=s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//while(now&amp;&amp;!tree[now].ch[ch])&#123;now=tree[now].fail;&#125;//不匹配,上跳;</span></span><br><span class="line">        now=tree[now].ch[ch];<span class="comment">//从下一层继续匹配;</span></span><br><span class="line">        <span class="keyword">int</span> temp=now;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            ans[temp]+=tree[temp].rec;</span><br><span class="line">            maxv=max(maxv,ans[temp]);</span><br><span class="line">            temp=tree[temp].fail;<span class="comment">//向上匹配统计答案;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c[i];insert(i);</span><br><span class="line">    &#125;init();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;match();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxv);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[pos[i]]==maxv)&#123;<span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    &#125;<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    ni=<span class="number">0</span>;maxv=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Manacher算法</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">21000001</span>];</span><br><span class="line"><span class="keyword">char</span> s_new[<span class="number">42000002</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">21000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> len = <span class="built_in">std</span>::<span class="built_in">strlen</span>(s);</span><br><span class="line">	s_new[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">	s_new[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s_new[j++] = s[i];</span><br><span class="line">		s_new[j++] = <span class="string">'#'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s_new[j] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = Init();</span><br><span class="line">	<span class="keyword">int</span> MaxLen = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i] = <span class="built_in">std</span>::min(p[<span class="number">2</span> * id - i], mx - i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			++p[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mx &lt; i + p[i])</span><br><span class="line">		&#123;</span><br><span class="line">			id = i;</span><br><span class="line">			mx = i + p[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MaxLen = <span class="built_in">std</span>::max(MaxLen, p[i] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Manacher() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">并查集（Rank优化）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100001&gt; Par &#123; <span class="number">0</span> &#125;, Rank &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Par[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> Par[x] = Find(Par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unite</span><span class="params">(T &amp;x, T &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = Find(x);</span><br><span class="line">	y = Find(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Rank[x] &lt; Rank[y])</span><br><span class="line">	&#123;</span><br><span class="line">		Par[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Par[y] = x;</span><br><span class="line">		<span class="keyword">if</span> (Rank[x] == Rank[y])</span><br><span class="line">			++Rank[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IsSame</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Find(x) == Find(y))</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'Y'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'N'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N, M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Par[i] = i;</span><br><span class="line">		Rank[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Z, X, Y;</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Z &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">		<span class="keyword">switch</span> (Z)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				Unite(X, Y);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				IsSame(X, Y);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">乘法逆元（递推）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, p;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, 3000001&gt; Arr &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	Arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Arr[i] = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((p - p / i) * Arr[p % i] % p);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">单源最短路径（优先队列优化）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxN = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> From, To, Dist;</span><br><span class="line"></span><br><span class="line">		Edge() = <span class="keyword">default</span>;</span><br><span class="line">		Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d) :</span><br><span class="line">			From(u), To(v), Dist(d)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; Edges;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, MaxN&gt; G;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, MaxN&gt; Done &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, MaxN&gt; d &#123; <span class="number">0</span> &#125;, p &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> From, <span class="keyword">int</span> To, <span class="keyword">int</span> Dist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Edges.emplace_back(From, To, Dist);</span><br><span class="line">	G[From].push_back(Edges.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> d, u;</span><br><span class="line"></span><br><span class="line">		HeapNode() = <span class="keyword">default</span>;</span><br><span class="line">		HeapNode(<span class="keyword">int</span> d, <span class="keyword">int</span> u) :</span><br><span class="line">			d(d), u(u)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HeapNode &amp;rhs) <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> ((ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &amp;&amp; ch != <span class="string">'-'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = n * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n * k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N, M, S;</span><br><span class="line">	N = Read();</span><br><span class="line">	M = Read();</span><br><span class="line">	S = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> From, To, Cost;</span><br><span class="line">		From = Read();</span><br><span class="line">		To = Read();</span><br><span class="line">		Cost = Read();</span><br><span class="line">		AddEdge(From, To, Cost);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;HeapNode&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	d[S] = <span class="number">0</span>;</span><br><span class="line">	Q.push(HeapNode(<span class="number">0</span>, S));</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> x = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> u = x.u;</span><br><span class="line">		<span class="keyword">if</span> (Done[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Done[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;e = Edges[G[u][i]];</span><br><span class="line">			<span class="keyword">if</span> (d[e.To] &gt; d[u] + e.Dist)</span><br><span class="line">			&#123;</span><br><span class="line">				d[e.To] = d[u] + e.Dist;</span><br><span class="line">				p[e.To] = G[u][i];</span><br><span class="line">				Q.push(HeapNode(d[e.To], e.To));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">多项式解析（最简式）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, p;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">ParsePolynomial</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Expr)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> Len = Expr.size();</span><br><span class="line">			<span class="keyword">decltype</span>(Len) i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (i &lt; Len)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> Sign = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (Expr[i] == <span class="string">'+'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					++i;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (Expr[i] == <span class="string">'-'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					Sign = <span class="number">-1</span>;</span><br><span class="line">					++i;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (i &lt; Len &amp;&amp; <span class="built_in">std</span>::<span class="built_in">isdigit</span>(Expr[i]))</span><br><span class="line">				&#123;</span><br><span class="line">					v = v * <span class="number">10</span> + Expr[i++] - <span class="string">'0'</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (i == Len)</span><br><span class="line">				&#123;</span><br><span class="line">					a.push_back(v);</span><br><span class="line">					p.push_back(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (v == <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						v = <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					v *= Sign;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (Expr[++i] == <span class="string">'^'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						a.push_back(v);</span><br><span class="line">						v = <span class="number">0</span>;</span><br><span class="line">						++i;</span><br><span class="line">						<span class="keyword">while</span> (i &lt; Len &amp;&amp; <span class="built_in">std</span>::<span class="built_in">isdigit</span>(Expr[i]))</span><br><span class="line">						&#123;</span><br><span class="line">							v = v * <span class="number">10</span> + Expr[i++] - <span class="string">'0'</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						p.push_back(v);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						a.push_back(v);</span><br><span class="line">						p.push_back(<span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">Mod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> MOD)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> n = a.size();</span><br><span class="line">			<span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> m = a[i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p[i]; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					m = <span class="keyword">static_cast</span>&lt;ll&gt;(m) * x % MOD;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				Ans = (<span class="keyword">static_cast</span>&lt;ll&gt;(Ans) + m) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> Ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;Expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = Expr.find(<span class="string">'/'</span>);</span><br><span class="line">	Polynomial Poly;</span><br><span class="line">	Poly.ParsePolynomial(Expr.substr(<span class="number">1</span>, p - <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> D = <span class="built_in">std</span>::stoi(Expr.substr(p + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Poly.p[<span class="number">0</span>] + <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Poly.Mod(i, D) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> NO = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> Expr;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Expr &amp;&amp; Expr[<span class="number">0</span>] != <span class="string">'.'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++NO &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="keyword">if</span> (Check(Expr))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">puts</span>(<span class="string">"Always an integer"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">puts</span>(<span class="string">"Not always an integer"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二分图匹配（Dinic）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> INF = <span class="number">999999999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, E;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, 2002&gt;, 2002&gt; Can &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> To, Cap, Rev;</span><br><span class="line"></span><br><span class="line">		Edge() = <span class="keyword">default</span>;</span><br><span class="line">		Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> rev) :</span><br><span class="line">			To(to), Cap(cap), Rev(rev)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;, 2002&gt; G;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 2002&gt; Level &#123; <span class="number">0</span> &#125;, Iter &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> From, <span class="keyword">int</span> To, <span class="keyword">int</span> Cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G[From].emplace_back(To, Cap, G[To].size());</span><br><span class="line">	G[To].emplace_back(From, <span class="number">0</span>, G[From].size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::fill(Level.begin(), Level.end(), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Que;</span><br><span class="line">	Level[s] = <span class="number">0</span>;</span><br><span class="line">	Que.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Que.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = Que.front();</span><br><span class="line">		Que.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[v].size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;e = G[v][i];</span><br><span class="line">			<span class="keyword">if</span> (e.Cap &gt; <span class="number">0</span> &amp;&amp; Level[e.To] &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Level[e.To] = Level[v] + <span class="number">1</span>;</span><br><span class="line">				Que.push(e.To);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v == t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = Iter[v]; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(G[v].size()); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> &amp;e = G[v][i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (e.Cap &gt; <span class="number">0</span> &amp;&amp; Level[v] &lt; Level[e.To])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = DFS(e.To, t, <span class="built_in">std</span>::min(f, e.Cap));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				e.Cap -= d;</span><br><span class="line">				G[e.To][e.Rev].Cap += d;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> d;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Flow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BFS(s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Level[t] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> Flow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::fill(Iter.begin(), Iter.end(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> F;</span><br><span class="line">		<span class="keyword">while</span> ((F = DFS(s, t, INF)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Flow += F;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	N = Read();</span><br><span class="line">	M = Read();</span><br><span class="line">	E = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> From, To;</span><br><span class="line">		From = Read();</span><br><span class="line">		To = Read();</span><br><span class="line">		<span class="keyword">if</span> (To &lt;= M)</span><br><span class="line">		&#123;</span><br><span class="line">			Can[From][To] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> S = N + M, T = S + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		AddEdge(S, i, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		AddEdge(N + i, T, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Can[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				AddEdge(i, N + j, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; MaxFlow(S, T) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">高斯消元法</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> mat = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;vec&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vec <span class="title">GaussJordan</span><span class="params">(<span class="keyword">const</span> mat &amp;A, <span class="keyword">const</span> vec &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> n = A.size();</span><br><span class="line">	<span class="function">mat <span class="title">B</span><span class="params">(n, vec(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			B[i][j] = A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		B[i][n] = b[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> Privot = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j = i; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(B[j][i]) &gt; <span class="built_in">std</span>::<span class="built_in">abs</span>(B[Privot][i]))</span><br><span class="line">			&#123;</span><br><span class="line">				Privot = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::swap(B[i], B[Privot]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(B[i][i]) &lt; EPS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> vec();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			B[i][j] /= B[i][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i != j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> k = i + <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">				&#123;</span><br><span class="line">					B[j][k] -= B[j][i] * B[i][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">vec <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		x[i] = B[i][n];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function">mat <span class="title">A</span><span class="params">(n, vec(n))</span></span>;</span><br><span class="line">	<span class="function">vec <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			A[i][j] = Read();</span><br><span class="line">		&#125;</span><br><span class="line">		B[i] = Read();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> Ans = GaussJordan(A, B);</span><br><span class="line">	<span class="keyword">if</span> (Ans.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;r : Ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">滑动窗口（单调队列）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 1000000 + 5&gt; a &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueryMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 1000000 + 5&gt; p &#123; <span class="number">0</span> &#125;, q &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Head = <span class="number">1</span>, Tail = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Head &lt;= Tail &amp;&amp; q[Tail] &lt;= a[i])</span><br><span class="line">		&#123;</span><br><span class="line">			--Tail;</span><br><span class="line">		&#125;</span><br><span class="line">		q[++Tail] = a[i];</span><br><span class="line">		p[Tail] = i;</span><br><span class="line">		<span class="keyword">while</span> (p[Head] &lt; i - k + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			++Head;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q[Head] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueryMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 1000000 + 5&gt; p &#123; <span class="number">0</span> &#125;, q &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Head = <span class="number">1</span>, Tail = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Head &lt;= Tail &amp;&amp; q[Tail] &gt;= a[i])</span><br><span class="line">		&#123;</span><br><span class="line">			--Tail;</span><br><span class="line">		&#125;</span><br><span class="line">		q[++Tail] = a[i];</span><br><span class="line">		p[Tail] = i;</span><br><span class="line">		<span class="keyword">while</span> (p[Head] &lt; i - k + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			++Head;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q[Head] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = Read();</span><br><span class="line">	k = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = Read();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	QueryMin();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	QueryMax();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">矩阵加速（数列）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ll&gt;;</span><br><span class="line"><span class="keyword">using</span> mat = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;vec&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat &amp;A, <span class="keyword">const</span> mat &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">mat <span class="title">C</span><span class="params">(A.size(), vec(B[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B.size(); ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].size(); ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mat <span class="keyword">operator</span>^(mat &amp;A, ll n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">mat <span class="title">B</span><span class="params">(A.size(), vec(A.size()))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		B[i][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			B = B * A;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		A = A * A;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">mat <span class="title">A</span><span class="params">(<span class="number">3</span>, vec(<span class="number">3</span>))</span></span>;</span><br><span class="line">		A[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		A[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		A[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		A[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		A[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">		A[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		A[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		A[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			A = <span class="built_in">std</span>::move(A ^ (n - <span class="number">3</span>));</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (A[<span class="number">0</span>][<span class="number">0</span>] + A[<span class="number">0</span>][<span class="number">1</span>] + A[<span class="number">0</span>][<span class="number">2</span>]) % <span class="number">1000000007</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">矩阵快速幂</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ll&gt;;</span><br><span class="line"><span class="keyword">using</span> mat = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;vec&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat &amp;A, <span class="keyword">const</span> mat &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">mat <span class="title">C</span><span class="params">(A.size(), vec(B[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; A.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (ll k = <span class="number">0</span>; k &lt; B.size(); ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].size(); ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mat <span class="keyword">operator</span>^(mat A, ll n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">mat <span class="title">B</span><span class="params">(A.size(), vec(A.size()))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; A.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		B[i][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			B = B * A;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		A = A * A;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">	<span class="function">mat <span class="title">A</span><span class="params">(n, vec(n))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A = A ^ k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">莫队</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxN = <span class="number">50000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> Left, Right, ID, Pos;</span><br><span class="line"></span><br><span class="line">		Query() = <span class="keyword">default</span>;</span><br><span class="line">		Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id, <span class="keyword">int</span> pos) :</span><br><span class="line">			Left(l), Right(r), ID(id), Pos(pos)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Pos == rhs.Pos)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> Right &lt; rhs.Right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> Pos &lt; rhs.Pos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	n = Read();</span><br><span class="line">	m = Read();</span><br><span class="line">	k = Read();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, MaxN&gt; Num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Num[i] = Read();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> s = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;Query, MaxN&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		l = Read();</span><br><span class="line">		r = Read();</span><br><span class="line">		a[i] = <span class="built_in">std</span>::move(Query(l, r, i, l / s));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.begin() + <span class="number">1</span>, a.begin() + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, MaxN&gt; cnt &#123; <span class="number">0</span> &#125;, Res;</span><br><span class="line">	<span class="keyword">int</span> Left = <span class="number">1</span>, Right = <span class="number">0</span>, Ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Left &gt; a[i].Left)</span><br><span class="line">		&#123;</span><br><span class="line">			--Left;</span><br><span class="line">			++cnt[Num[Left]];</span><br><span class="line">			Ans += <span class="number">2</span> * cnt[Num[Left]] - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Right &lt; a[i].Right)</span><br><span class="line">		&#123;</span><br><span class="line">			++Right;</span><br><span class="line">			++cnt[Num[Right]];</span><br><span class="line">			Ans += <span class="number">2</span> * cnt[Num[Right]] - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Left &lt; a[i].Left)</span><br><span class="line">		&#123;</span><br><span class="line">			--cnt[Num[Left]];</span><br><span class="line">			Ans -= <span class="number">2</span> * cnt[Num[Left]] + <span class="number">1</span>;</span><br><span class="line">			++Left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Right &gt; a[i].Right)</span><br><span class="line">		&#123;</span><br><span class="line">			--cnt[Num[Right]];</span><br><span class="line">			Ans -= <span class="number">2</span> * cnt[Num[Right]] + <span class="number">1</span>;</span><br><span class="line">			--Right;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Res[a[i].ID] = Ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Res[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">强连通分量（Tarjan）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, 50001&gt; G, RG;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, 50001&gt; Used &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 50001&gt; Cmp &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> From, <span class="keyword">int</span> To)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G[From].push_back(To);</span><br><span class="line">	RG[To].push_back(From);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Used[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; G[v].size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Used[G[v][i]])</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G[v][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	VS.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RDFS</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Used[v] = <span class="literal">true</span>;</span><br><span class="line">	Cmp[v] = k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; RG[v].size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Used[RG[v][i]])</span><br><span class="line">		&#123;</span><br><span class="line">			RDFS(RG[v][i], k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SCC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Used[v])</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::fill(Used.begin(), Used.end(), <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(VS.size()) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Used[VS[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			RDFS(VS[i], k++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N, M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 50001&gt; A &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 50001&gt; B &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; A[i] &gt;&gt; B[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	V = N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		AddEdge(A[i] - <span class="number">1</span>, B[i] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = SCC();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Cmp[v] == n - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			u = v;</span><br><span class="line">			++num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::fill(Used.begin(), Used.end(), <span class="literal">false</span>);</span><br><span class="line">	RDFS(u, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Used[v])</span><br><span class="line">		&#123;</span><br><span class="line">			num = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">三分法（秦九韶公式优化）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 15&gt; a &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> Left, Right, MidL, MidR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> Sum = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Sum = Sum * x + a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Left &gt;&gt; Right;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (Right - Left &gt; EPS)</span><br><span class="line">	&#123;</span><br><span class="line">		MidL = (Left + Right) / <span class="number">2</span>;</span><br><span class="line">		MidR = (MidL + Right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (f(MidL) &gt;= f(MidR))</span><br><span class="line">		&#123;</span><br><span class="line">			Right = MidR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Left = MidL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, Left);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">树状数组（差分&amp;单点询问）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 500001&gt; Bit &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s += Bit[i];</span><br><span class="line">		i -= i &amp; -i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		Bit[i] += x;</span><br><span class="line">		i += i &amp; -i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Last = <span class="number">0</span>, Now;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Now;</span><br><span class="line">		Add(i, Now - Last);</span><br><span class="line">		Last = Now;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Command;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Command;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Command == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, y, k;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			Add(x, k);</span><br><span class="line">			Add(y + <span class="number">1</span>, -k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Command == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Sum(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">树状数组（区间和）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 500001&gt; Bit &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s += Bit[i];</span><br><span class="line">		i -= i &amp; -i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		Bit[i] += x;</span><br><span class="line">		i += i &amp; -i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		t = Read();</span><br><span class="line">		Add(i, t);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Command;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Command;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Command == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, k;</span><br><span class="line">			x = Read();</span><br><span class="line">			k = Read();</span><br><span class="line">			Add(x, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Command == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			x = Read();</span><br><span class="line">			y = Read();</span><br><span class="line"></span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Sum(y) - Sum(x - <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">凸包</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> EPS = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(a + b) &lt; EPS * (<span class="built_in">std</span>::<span class="built_in">abs</span>(a) + <span class="built_in">std</span>::<span class="built_in">abs</span>(b)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">double</span> x, y;</span><br><span class="line">		Point() = <span class="keyword">default</span>;</span><br><span class="line">		Point(<span class="keyword">double</span> X, <span class="keyword">double</span> Y) :</span><br><span class="line">			x(X), y(Y)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> Point(Add(x, p.x), Add(y, p.y));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> Point(Add(x, -p.x), Add(y, -p.y));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Point <span class="keyword">operator</span>*(<span class="keyword">double</span> d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> Point(x * d, y * d);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Add(x * p.x, y * p.y);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">Det</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Add(x * p.y, -y * p.x);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ConvexHull(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; &amp;ps)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(ps.begin(), ps.end(), [](<span class="keyword">const</span> Point &amp;p, <span class="keyword">const</span> Point &amp;q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p.x != q.x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> p.x &lt; q.x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> p.y &lt; q.y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; qs(ps.size() * <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ps.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; (qs[k - <span class="number">1</span>] - qs[k - <span class="number">2</span>]).Det(ps[i] - qs[k - <span class="number">1</span>]) &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			--k;</span><br><span class="line">		&#125;</span><br><span class="line">		qs[k++] = ps[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ps.size() - <span class="number">2</span>), t = k; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; t &amp;&amp; (qs[k - <span class="number">1</span>] - qs[k - <span class="number">2</span>]).Det(ps[i] - qs[k - <span class="number">1</span>]) &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			--k;</span><br><span class="line">		&#125;</span><br><span class="line">		qs[k++] = ps[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	qs.resize(k - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> qs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist</span><span class="params">(<span class="keyword">const</span> Point &amp;p, <span class="keyword">const</span> Point &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ps;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		ps.emplace_back(x, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> qs = ConvexHull(ps);</span><br><span class="line">	<span class="keyword">double</span> Res = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (qs.size() == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>, Dist(qs[<span class="number">0</span>], qs[<span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; qs.size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				Res = <span class="built_in">std</span>::max(Res, Dist(qs[i], qs[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>, Res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">网络最大流（Dinic）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, S, T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> To, Cap, Rev;</span><br><span class="line"></span><br><span class="line">		Edge() = <span class="keyword">default</span>;</span><br><span class="line">		Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> rev) : To(to), Cap(cap), Rev(rev)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;, 10001&gt; G;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10001&gt; Level, Iter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> From, <span class="keyword">int</span> To, <span class="keyword">int</span> Cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G[From].emplace_back(To, Cap, G[To].size());</span><br><span class="line">	G[To].emplace_back(From, <span class="number">0</span>, G[From].size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::fill(Level.begin(), Level.end(), <span class="number">-1</span>);</span><br><span class="line">	Level[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Que;</span><br><span class="line">	Que.push(S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!Que.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> v = Que.front();</span><br><span class="line">		Que.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;e = G[v][i];</span><br><span class="line">			<span class="keyword">if</span> (e.Cap &gt; <span class="number">0</span> &amp;&amp; Level[e.To] &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Level[e.To] = Level[v] + <span class="number">1</span>;</span><br><span class="line">				Que.push(e.To);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v == t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = Iter[v]; i &lt; G[v].size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> &amp;e = G[v][i];</span><br><span class="line">		<span class="keyword">if</span> (e.Cap &gt; <span class="number">0</span> &amp;&amp; Level[v] &lt; Level[e.To])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = DFS(e.To, t, <span class="built_in">std</span>::min(f, e.Cap));</span><br><span class="line">			<span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				e.Cap -= d;</span><br><span class="line">				G[e.To][e.Rev].Cap += d;</span><br><span class="line">				<span class="keyword">return</span> d;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BFS(s);</span><br><span class="line">		<span class="keyword">if</span> (Level[t] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> Flow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::fill(Iter.begin(), Iter.end(), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> f;</span><br><span class="line">		<span class="keyword">while</span> ((f = DFS(s, t, INF)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Flow += f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		AddEdge(u, v, w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; MaxFlow(S, T) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线段树（RMQ）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxM = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;ll, MaxM &lt;&lt; 2&gt; Tree &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll Root, ll l, ll r, ll Pos, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[Root] = k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (Mid &gt;= Pos)</span><br><span class="line">	&#123;</span><br><span class="line">		Update(Root * <span class="number">2</span>, l, Mid, Pos, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Update(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, r, Pos, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Tree[Root] = <span class="built_in">std</span>::max(Tree[Root * <span class="number">2</span>], Tree[Root * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l, ll r, ll ql, ll qr, ll Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Tree[Root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (qr &lt; l || ql &gt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::max(Query(l, Mid, ql, qr, Root * <span class="number">2</span>), Query(Mid + <span class="number">1</span>, r, ql, qr, Root * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll M;</span><br><span class="line">	ll D;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; D;</span><br><span class="line">	ll Last = <span class="number">0</span>;</span><br><span class="line">	ll x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> Command;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Command;</span><br><span class="line">		<span class="keyword">if</span> (Command == <span class="string">'A'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ll k;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">			Update(<span class="number">1</span>, <span class="number">1</span>, MaxM, ++Last, (x + k) % D);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ll r;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line">			x = Query(<span class="number">1</span>, MaxM, Last - r + <span class="number">1</span>, Last, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线段树（区间和&amp;乘）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxN = <span class="number">400000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		ll Val, LazyTagAdd, LazyTagMul;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;tree, MaxN&gt; Tree;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;ll, MaxN&gt; Arr &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">ll Mod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll Root, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree[Root].LazyTagAdd = <span class="number">0</span>;</span><br><span class="line">	Tree[Root].LazyTagMul = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[Root].Val = Arr[l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		Build(Root * <span class="number">2</span>, l, Mid);</span><br><span class="line">		Build(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, r);</span><br><span class="line">		Tree[Root].Val = Tree[Root * <span class="number">2</span>].Val + Tree[Root * <span class="number">2</span> + <span class="number">1</span>].Val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Tree[Root].Val %= Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(ll Root, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	Tree[Root * <span class="number">2</span>].Val = (Tree[Root * <span class="number">2</span>].Val * Tree[Root].LazyTagMul</span><br><span class="line">	                      + Tree[Root].LazyTagAdd * (Mid - l + <span class="number">1</span>)) % Mod;</span><br><span class="line">	Tree[Root * <span class="number">2</span> + <span class="number">1</span>].Val = (Tree[Root * <span class="number">2</span> + <span class="number">1</span>].Val * Tree[Root].LazyTagMul</span><br><span class="line">	                          + Tree[Root].LazyTagAdd * (r - Mid)) % Mod;</span><br><span class="line"></span><br><span class="line">	Tree[Root * <span class="number">2</span>].LazyTagMul = (Tree[Root * <span class="number">2</span>].LazyTagMul * Tree[Root].LazyTagMul) % Mod;</span><br><span class="line">	Tree[Root * <span class="number">2</span> + <span class="number">1</span>].LazyTagMul = (Tree[Root * <span class="number">2</span> + <span class="number">1</span>].LazyTagMul * Tree[Root].LazyTagMul) % Mod;</span><br><span class="line">	Tree[Root * <span class="number">2</span>].LazyTagAdd = (Tree[Root * <span class="number">2</span>].LazyTagAdd * Tree[Root].LazyTagMul + Tree[Root].LazyTagAdd) % Mod;</span><br><span class="line">	Tree[Root * <span class="number">2</span> + <span class="number">1</span>].LazyTagAdd = (Tree[Root * <span class="number">2</span> + <span class="number">1</span>].LazyTagAdd * Tree[Root].LazyTagMul + Tree[Root].LazyTagAdd) % Mod;</span><br><span class="line"></span><br><span class="line">	Tree[Root].LazyTagAdd = <span class="number">0</span>;</span><br><span class="line">	Tree[Root].LazyTagMul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateMul</span><span class="params">(ll Root, ll l, ll r, ll rl, ll rr, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; rr || rl &gt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rl &lt;= l &amp;&amp; rr &gt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[Root].Val = (Tree[Root].Val * k) % Mod;</span><br><span class="line">		Tree[Root].LazyTagMul = (Tree[Root].LazyTagMul * k) % Mod;</span><br><span class="line">		Tree[Root].LazyTagAdd = (Tree[Root].LazyTagAdd * k) % Mod;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PushDown(Root, l, r);</span><br><span class="line">	<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	UpdateMul(Root * <span class="number">2</span>, l, Mid, rl, rr, k);</span><br><span class="line">	UpdateMul(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, r, rl, rr, k);</span><br><span class="line">	Tree[Root].Val = (Tree[Root * <span class="number">2</span>].Val + Tree[Root * <span class="number">2</span> + <span class="number">1</span>].Val) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateAdd</span><span class="params">(ll Root, ll l, ll r, ll rl, ll rr, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rr &lt; l || rl &gt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rl &lt;= l &amp;&amp; rr &gt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[Root].LazyTagAdd = (Tree[Root].LazyTagAdd + k) % Mod;</span><br><span class="line">		Tree[Root].Val = (Tree[Root].Val + k * (r - l + <span class="number">1</span>)) % Mod;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PushDown(Root, l, r);</span><br><span class="line">	<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	UpdateAdd(Root * <span class="number">2</span>, l, Mid, rl, rr, k);</span><br><span class="line">	UpdateAdd(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, r, rl, rr, k);</span><br><span class="line">	Tree[Root].Val = (Tree[Root * <span class="number">2</span>].Val + Tree[Root * <span class="number">2</span> + <span class="number">1</span>].Val) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll Root, ll l, ll r, ll rl, ll rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rr &lt; l || rl &gt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rl &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Tree[Root].Val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PushDown(Root, l, r);</span><br><span class="line">	<span class="keyword">auto</span> Mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> (Query(Root * <span class="number">2</span>, l, Mid, rl, rr) + Query(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, r, rl, rr)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll N, M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Mod;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Build(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		ll Command;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Command;</span><br><span class="line">		ll l, r, k;</span><br><span class="line">		<span class="keyword">if</span> (Command == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">			UpdateMul(<span class="number">1</span>, <span class="number">1</span>, N, l, r, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Command == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">			UpdateAdd(<span class="number">1</span>, <span class="number">1</span>, N, l, r, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Query(<span class="number">1</span>, <span class="number">1</span>, N, l, r) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线段树（区间和）</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100000&gt; Arr &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll Val, LazyTag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;Node, 400000&gt; SegTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> Root, <span class="keyword">const</span> T &amp;Arr, <span class="keyword">int</span> Start, <span class="keyword">int</span> End)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SegTree[Root].LazyTag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Start == End)</span><br><span class="line">	&#123;</span><br><span class="line">		SegTree[Root].Val = Arr[Start];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Mid = (Start + End) / <span class="number">2</span>;</span><br><span class="line">		Build(Root * <span class="number">2</span>, Arr, Start, Mid);</span><br><span class="line">		Build(Root * <span class="number">2</span> + <span class="number">1</span>, Arr, Mid + <span class="number">1</span>, End);</span><br><span class="line">		SegTree[Root].Val = SegTree[Root * <span class="number">2</span>].Val + SegTree[Root * <span class="number">2</span> + <span class="number">1</span>].Val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> Root, <span class="keyword">int</span> Start, <span class="keyword">int</span> End)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (SegTree[Root].LazyTag != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SegTree[Root * <span class="number">2</span>].LazyTag += SegTree[Root].LazyTag;</span><br><span class="line">		SegTree[Root * <span class="number">2</span> + <span class="number">1</span>].LazyTag += SegTree[Root].LazyTag;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> Mid = (Start + End) / <span class="number">2</span>;</span><br><span class="line">		SegTree[Root * <span class="number">2</span>].Val += SegTree[Root].LazyTag * (Mid - Start + <span class="number">1</span>);</span><br><span class="line">		SegTree[Root * <span class="number">2</span> + <span class="number">1</span>].Val += SegTree[Root].LazyTag * (End - Mid);</span><br><span class="line"></span><br><span class="line">		SegTree[Root].LazyTag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> Root, <span class="keyword">int</span> NStart, <span class="keyword">int</span> NEnd, <span class="keyword">int</span> QStart, <span class="keyword">int</span> QEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (QStart &gt; NEnd || QEnd &lt; NStart)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (QStart &lt;= NStart &amp;&amp; QEnd &gt;= NEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> SegTree[Root].Val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PushDown(Root, NStart, NEnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Mid = (NStart + NEnd) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> Query(Root * <span class="number">2</span>, NStart, Mid, QStart, QEnd)</span><br><span class="line">	       + Query(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, NEnd, QStart, QEnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> Root, <span class="keyword">int</span> NStart, <span class="keyword">int</span> Nend, <span class="keyword">int</span> UStart, <span class="keyword">int</span> UEnd, <span class="keyword">int</span> AddVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (UStart &gt; Nend || UEnd &lt; NStart)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (UStart &lt;= NStart &amp;&amp; UEnd &gt;= Nend)</span><br><span class="line">	&#123;</span><br><span class="line">		SegTree[Root].LazyTag += AddVal;</span><br><span class="line">		SegTree[Root].Val += AddVal * (Nend - NStart + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PushDown(Root, NStart, Nend);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Mid = (NStart + Nend) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	Update(Root * <span class="number">2</span>, NStart, Mid, UStart, UEnd, AddVal);</span><br><span class="line">	Update(Root * <span class="number">2</span> + <span class="number">1</span>, Mid + <span class="number">1</span>, Nend, UStart, UEnd, AddVal);</span><br><span class="line"></span><br><span class="line">	SegTree[Root].Val = SegTree[Root * <span class="number">2</span>].Val + SegTree[Root * <span class="number">2</span> + <span class="number">1</span>].Val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Build(<span class="number">1</span>, Arr, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Command;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Command;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Command == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, y, k;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			Update(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Command == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Query(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最小生成树</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 200001&gt; Par &#123; <span class="number">0</span> &#125;, Rank &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Par[x] == x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Par[x] = Find(Par[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> T &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Par[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unite</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = Find(x);</span><br><span class="line">	y = Find(y);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x == y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Rank[x] &lt; Rank[y])</span><br><span class="line">	&#123;</span><br><span class="line">		Par[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Par[y] = x;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Rank[x] == Rank[y])</span><br><span class="line">		&#123;</span><br><span class="line">			++Rank[x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSame</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> From, To, Cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;struct Edge, 200001&gt; Edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N, M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Edges[i].From &gt;&gt; Edges[i].To &gt;&gt; Edges[i].Cost;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::sort(Edges.begin(), Edges.begin() + M, [](<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.Cost &lt; b.Cost;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	Init(N);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> e = Edges[i];</span><br><span class="line">		<span class="keyword">if</span> (!IsSame(e.From, e.To))</span><br><span class="line">		&#123;</span><br><span class="line">			Unite(e.From, e.To);</span><br><span class="line">			Res += e.Cost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最长上升子序列（o(nlogn))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100002&gt; Origin &#123; <span class="number">0</span> &#125;, Stack &#123; <span class="number">0</span> &#125;, dp &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Num;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Num;</span><br><span class="line">		Origin[Num] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Num;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Num;</span><br><span class="line">		Stack[i] = Origin[Num];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::fill(dp.begin(), dp.begin() + n, INT_MAX);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		*<span class="built_in">std</span>::lower_bound(dp.begin(), dp.begin() + n, Stack[i]) = Stack[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::lower_bound(dp.begin(), dp.begin() + n, INT_MAX) - dp.begin() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie（左儿子右兄弟表示法）：P210(UVa11732)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">4000</span> * <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> sigma_size = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字母表为全体小写字母的Trie</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> head[maxnode]; <span class="comment">// head[i]为第i个结点的左儿子编号</span></span><br><span class="line">		<span class="keyword">int</span> next[maxnode]; <span class="comment">// next[i]为第i个结点的右兄弟编号</span></span><br><span class="line">		<span class="keyword">char</span> ch[maxnode];  <span class="comment">// ch[i]为第i个结点上的字符</span></span><br><span class="line">		<span class="keyword">int</span> tot[maxnode];  <span class="comment">// tot[i]为第i个结点为根的子树包含的叶结点总数</span></span><br><span class="line">		<span class="keyword">int</span> sz; <span class="comment">// 结点总数</span></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans; <span class="comment">// 答案</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			sz = <span class="number">1</span>;    <span class="comment">// 初始时只有一个根结点</span></span><br><span class="line">			tot[<span class="number">0</span>] = head[<span class="number">0</span>] = next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 插入字符串s（包括最后的'\0'），沿途更新tot</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u = <span class="number">0</span>, v, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">			tot[<span class="number">0</span>]++;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 找字符a[i]</span></span><br><span class="line">				<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">for</span>(v = head[u]; v != <span class="number">0</span>; v = next[v])</span><br><span class="line">					<span class="keyword">if</span>(ch[v] == s[i])   <span class="comment">// 找到了</span></span><br><span class="line">					&#123;</span><br><span class="line">						found = <span class="literal">true</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">if</span>(!found)</span><br><span class="line">				&#123;</span><br><span class="line">					v = sz++; <span class="comment">// 新建结点</span></span><br><span class="line">					tot[v] = <span class="number">0</span>;</span><br><span class="line">					ch[v] = s[i];</span><br><span class="line">					next[v] = head[u];</span><br><span class="line">					head[u] = v; <span class="comment">// 插入到链表的首部</span></span><br><span class="line">					head[v] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				u = v;</span><br><span class="line">				tot[u]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 统计LCP=u的所有单词两两的比较次数之和</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(head[u] == <span class="number">0</span>) <span class="comment">// 叶结点</span></span><br><span class="line">				ans += tot[u] * (tot[u] - <span class="number">1</span>) * depth;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> v = head[u]; v != <span class="number">0</span>; v = next[v])</span><br><span class="line">					sum += tot[v] * (tot[u] - tot[v]); <span class="comment">// 子树v中选一个串，其他子树中再选一个</span></span><br><span class="line">				ans += sum / <span class="number">2</span> * (<span class="number">2</span> * depth + <span class="number">1</span>); <span class="comment">// 除以2是每种选法统计了两次</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> v = head[u]; v != <span class="number">0</span>; v = next[v])</span><br><span class="line">					dfs(depth+<span class="number">1</span>, v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 统计</span></span><br><span class="line">		<span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			ans = <span class="number">0</span>;</span><br><span class="line">			dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1000</span> + <span class="number">10</span>;   <span class="comment">// 每个单词最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> word[maxl];</span><br><span class="line">Trie trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		trie.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, word);</span><br><span class="line">			trie.insert(word);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, kase++, trie.count());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie（普通表示法）：P209(LA3492)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">4000</span> * <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> sigma_size = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字母表为全体小写字母的Trie</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line">		<span class="keyword">int</span> val[maxnode];</span><br><span class="line">		<span class="keyword">int</span> sz; <span class="comment">// 结点总数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			sz = <span class="number">1</span>;    <span class="comment">// 初始时只有一个根结点</span></span><br><span class="line">			<span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c - <span class="string">'a'</span>;    <span class="comment">// 字符c的编号</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 插入字符串s，附加信息为v。注意v必须非0，因为0代表"本结点不是单词结点"</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">				<span class="keyword">if</span>(!ch[u][c])   <span class="comment">// 结点不存在</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">					val[sz] = <span class="number">0</span>;  <span class="comment">// 中间结点的附加信息为0</span></span><br><span class="line">					ch[u][c] = sz++; <span class="comment">// 新建结点</span></span><br><span class="line">				&#125;</span><br><span class="line">				u = ch[u][c]; <span class="comment">// 往下走</span></span><br><span class="line">			&#125;</span><br><span class="line">			val[u] = v; <span class="comment">// 字符串的最后一个字符的附加信息为v</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找字符串s的长度不超过len的前缀</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">find_prefixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i] == <span class="string">'\0'</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">				<span class="keyword">if</span>(!ch[u][c]) <span class="keyword">break</span>;</span><br><span class="line">				u = ch[u][c];</span><br><span class="line">				<span class="keyword">if</span>(val[u] != <span class="number">0</span>) ans.push_back(val[u]); <span class="comment">// 找到一个前缀</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">300000</span> + <span class="number">10</span>; <span class="comment">// 文本串最大长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">4000</span> + <span class="number">10</span>;   <span class="comment">// 单词最大个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxwl = <span class="number">100</span> + <span class="number">10</span>;   <span class="comment">// 每个单词最大长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20071027</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxl], len[maxw], S;</span><br><span class="line"><span class="keyword">char</span> text[maxl], word[maxwl];</span><br><span class="line">Trie trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, text, &amp;S) == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		trie.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, word);</span><br><span class="line">			len[i] = <span class="built_in">strlen</span>(word);</span><br><span class="line">			trie.insert(word, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="keyword">int</span> L = <span class="built_in">strlen</span>(text);</span><br><span class="line">		d[L] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">			trie.find_prefixes(text+i, L-i, p);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size(); j++)</span><br><span class="line">				d[i] = (d[i] + d[i+len[p[j]]]) % MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, kase++, d[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树（推平一段区间）：P207(UVa11992)</span></span><br><span class="line"><span class="comment">// 注意：所有叶子上总是保留set标记而不会被清除（pushdown只能针对非叶结点），因此maintain函数对于叶子来说并不会重复累加addv[o]</span></span><br><span class="line"><span class="comment">// 本程序在query的时候没有进行标记传递（即pushdown），而是用其他方法完成了查询。虽然执行效率提高，但在一定程度上牺牲了可读性</span></span><br><span class="line"><span class="comment">// 有兴趣的读者请参考代码仓库中的uva11992b.cpp，那个写法更具一般性，只是执行效率较低</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> _sum, _min, _max, op, x1, x2, y1, y2, x, v;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">IntervalTree</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> sumv[maxnode], minv[maxnode], maxv[maxnode], setv[maxnode], addv[maxnode];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 维护信息</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(R &gt; L)</span><br><span class="line">			&#123;</span><br><span class="line">				sumv[o] = sumv[lc] + sumv[rc];</span><br><span class="line">				minv[o] = min(minv[lc], minv[rc]);</span><br><span class="line">				maxv[o] = max(maxv[lc], maxv[rc]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(setv[o] &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				minv[o] = maxv[o] = setv[o];</span><br><span class="line">				sumv[o] = setv[o] * (R-L+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(addv[o])</span><br><span class="line">			&#123;</span><br><span class="line">				minv[o] += addv[o];</span><br><span class="line">				maxv[o] += addv[o];</span><br><span class="line">				sumv[o] += addv[o] * (R-L+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标记传递</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(setv[o] &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				setv[lc] = setv[rc] = setv[o];</span><br><span class="line">				addv[lc] = addv[rc] = <span class="number">0</span>;</span><br><span class="line">				setv[o] = <span class="number">-1</span>; <span class="comment">// 清除本结点标记</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(addv[o])</span><br><span class="line">			&#123;</span><br><span class="line">				addv[lc] += addv[o];</span><br><span class="line">				addv[rc] += addv[o];</span><br><span class="line">				addv[o] = <span class="number">0</span>; <span class="comment">// 清除本结点标记</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(y1 &lt;= L &amp;&amp; y2 &gt;= R)   <span class="comment">// 标记修改</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(op == <span class="number">1</span>) addv[o] += v;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					setv[o] = v;</span><br><span class="line">					addv[o] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				pushdown(o);</span><br><span class="line">				<span class="keyword">int</span> M = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(y1 &lt;= M) update(lc, L, M);</span><br><span class="line">				<span class="keyword">else</span> maintain(lc, L, M);</span><br><span class="line">				<span class="keyword">if</span>(y2 &gt; M) update(rc, M+<span class="number">1</span>, R);</span><br><span class="line">				<span class="keyword">else</span> maintain(rc, M+<span class="number">1</span>, R);</span><br><span class="line">			&#125;</span><br><span class="line">			maintain(o, L, R);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(setv[o] &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> v = setv[o] + add + addv[o];</span><br><span class="line">				_sum += v * (min(R,y2)-max(L,y1)+<span class="number">1</span>);</span><br><span class="line">				_min = min(_min, v);</span><br><span class="line">				_max = max(_max, v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(y1 &lt;= L &amp;&amp; y2 &gt;= R)</span><br><span class="line">			&#123;</span><br><span class="line">				_sum += sumv[o] + add * (R-L+<span class="number">1</span>);</span><br><span class="line">				_min = min(_min, minv[o] + add);</span><br><span class="line">				_max = max(_max, maxv[o] + add);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> M = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(y1 &lt;= M) query(o*<span class="number">2</span>, L, M, add + addv[o]);</span><br><span class="line">				<span class="keyword">if</span>(y2 &gt; M) query(o*<span class="number">2</span>+<span class="number">1</span>, M+<span class="number">1</span>, R, add + addv[o]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxr = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">IntervalTree tree[maxr];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r, c, m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;r, &amp;c, &amp;m) == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">		<span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= r; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(tree[x].setv, <span class="number">-1</span>, <span class="keyword">sizeof</span>(tree[x].setv));</span><br><span class="line">			tree[x].setv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(m--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;op, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">			<span class="keyword">if</span>(op &lt; <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">				<span class="keyword">for</span>(x = x1; x &lt;= x2; x++) tree[x].update(<span class="number">1</span>, <span class="number">1</span>, c);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				_sum = <span class="number">0</span>;</span><br><span class="line">				_min = INF;</span><br><span class="line">				_max = -INF;</span><br><span class="line">				<span class="keyword">for</span>(x = x1; x &lt;= x2; x++) tree[x].query(<span class="number">1</span>, <span class="number">1</span>, c, <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, _sum, _min, _max);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树（动态最大连续和）：P201(LA3938)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">		<span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Interval;</span><br><span class="line"></span><br><span class="line">		LL prefix_sum[maxn];</span><br><span class="line"></span><br><span class="line">		<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prefix_sum[R] - prefix_sum[L<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(Interval p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum(p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Interval <span class="title">better</span><span class="params">(Interval a, Interval b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum(a) != sum(b)) <span class="keyword">return</span> sum(a) &gt; sum(b) ? a : b;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b; <span class="comment">// 利用pair自带的字典序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qL, qR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntervalTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> max_prefix[maxnode];</span><br><span class="line">	<span class="keyword">int</span> max_suffix[maxnode];</span><br><span class="line">	Interval max_sub[maxnode];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L == R)</span><br><span class="line">		&#123;</span><br><span class="line">			max_prefix[o] = max_suffix[o] = L;</span><br><span class="line">			max_sub[o] = make_pair(L, L);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> M = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">			<span class="comment">// 递归创建子树</span></span><br><span class="line">			<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			build(lc, L, M);</span><br><span class="line">			build(rc, M+<span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 递推max_prefix</span></span><br><span class="line">			LL v1 = sum(L, max_prefix[lc]);</span><br><span class="line">			LL v2 = sum(L, max_prefix[rc]);</span><br><span class="line">			<span class="keyword">if</span>(v1 == v2) max_prefix[o] = min(max_prefix[lc], max_prefix[rc]);</span><br><span class="line">			<span class="keyword">else</span> max_prefix[o] = v1 &gt; v2 ? max_prefix[lc] : max_prefix[rc];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 递推max_suffix</span></span><br><span class="line">			v1 = sum(max_suffix[lc], R);</span><br><span class="line">			v2 = sum(max_suffix[rc], R);</span><br><span class="line">			<span class="keyword">if</span>(v1 == v2) max_suffix[o] = min(max_suffix[lc], max_suffix[rc]);</span><br><span class="line">			<span class="keyword">else</span> max_suffix[o] = v1 &gt; v2 ? max_suffix[lc] : max_suffix[rc];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 递推max_sub</span></span><br><span class="line">			max_sub[o] = better(max_sub[lc], max_sub[rc]); <span class="comment">// 完全在左子树或者右子树</span></span><br><span class="line">			max_sub[o] = better(max_sub[o], make_pair(max_suffix[lc], max_prefix[rc])); <span class="comment">// 跨越中线</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Interval <span class="title">query_prefix</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(max_prefix[o] &lt;= qR) <span class="keyword">return</span> make_pair(L, max_prefix[o]);</span><br><span class="line">		<span class="keyword">int</span> M = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(qR &lt;= M) <span class="keyword">return</span> query_prefix(lc, L, M);</span><br><span class="line">		Interval i = query_prefix(rc, M+<span class="number">1</span>, R);</span><br><span class="line">		i.first = L;</span><br><span class="line">		<span class="keyword">return</span> better(i, make_pair(L, max_prefix[lc]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Interval <span class="title">query_suffix</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(max_suffix[o] &gt;= qL) <span class="keyword">return</span> make_pair(max_suffix[o], R);</span><br><span class="line">		<span class="keyword">int</span> M = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(qL &gt; M) <span class="keyword">return</span> query_suffix(rc, M+<span class="number">1</span>, R);</span><br><span class="line">		Interval i = query_suffix(lc, L, M);</span><br><span class="line">		i.second = R;</span><br><span class="line">		<span class="keyword">return</span> better(i, make_pair(max_suffix[rc], R));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Interval <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(qL &lt;= L &amp;&amp; R &lt;= qR) <span class="keyword">return</span> max_sub[o];</span><br><span class="line">		<span class="keyword">int</span> M = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> lc = o*<span class="number">2</span>, rc = o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(qR &lt;= M) <span class="keyword">return</span> query(lc, L, M);</span><br><span class="line">		<span class="keyword">if</span>(qL &gt; M) <span class="keyword">return</span> query(rc, M+<span class="number">1</span>, R);</span><br><span class="line">		Interval i1 = query_prefix(rc, M+<span class="number">1</span>, R); <span class="comment">// 右半的前缀</span></span><br><span class="line">		Interval i2 = query_suffix(lc, L, M); <span class="comment">// 左半的后缀</span></span><br><span class="line">		Interval i3 = better(query(lc, L, M), query(rc, M+<span class="number">1</span>, R));</span><br><span class="line">		<span class="keyword">return</span> better(make_pair(i2.first, i1.second), i3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IntervalTree tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kase = <span class="number">0</span>, n, a, Q;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q) == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		prefix_sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			prefix_sum[i+<span class="number">1</span>] = prefix_sum[i] + a;</span><br><span class="line">		&#125;</span><br><span class="line">		tree.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++kase);</span><br><span class="line">		<span class="keyword">while</span>(Q--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> L, R;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">			qL = L;</span><br><span class="line">			qR = R;</span><br><span class="line">			Interval ans = tree.query(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans.first, ans.second);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AC自动机 （P216（LA5670））</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> SIGMA_SIZE = <span class="number">26</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> MAXNODE = <span class="number">11000</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> MAXS = <span class="number">150</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; ms;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">AhoCorasickAutomata</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> ch[MAXNODE][SIGMA_SIZE];</span><br><span class="line">		<span class="keyword">int</span> f[MAXNODE];    <span class="comment">// fail函数</span></span><br><span class="line">		<span class="keyword">int</span> val[MAXNODE];  <span class="comment">// 每个字符串的结尾结点都有一个非0的val</span></span><br><span class="line">		<span class="keyword">int</span> last[MAXNODE]; <span class="comment">// 输出链表的下一个结点</span></span><br><span class="line">		<span class="keyword">int</span> cnt[MAXS];</span><br><span class="line">		<span class="keyword">int</span> sz;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			sz = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">			<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">			ms.clear();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 字符c的编号</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c-<span class="string">'a'</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 插入字符串。v必须非0</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">				<span class="keyword">if</span>(!ch[u][c])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">					val[sz] = <span class="number">0</span>;</span><br><span class="line">					ch[u][c] = sz++;</span><br><span class="line">				&#125;</span><br><span class="line">				u = ch[u][c];</span><br><span class="line">			&#125;</span><br><span class="line">			val[u] = v;</span><br><span class="line">			ms[<span class="built_in">string</span>(s)] = v;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归打印以结点j结尾的所有字符串</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(j)</span><br><span class="line">			&#123;</span><br><span class="line">				cnt[val[j]]++;</span><br><span class="line">				print(last[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在T中找模板</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> n = <span class="built_in">strlen</span>(T);</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 当前结点编号，初始为根结点</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 文本串当前指针</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> c = idx(T[i]);</span><br><span class="line">				<span class="keyword">while</span>(j &amp;&amp; !ch[j][c]) j = f[j]; <span class="comment">// 顺着细边走，直到可以匹配</span></span><br><span class="line">				j = ch[j][c];</span><br><span class="line">				<span class="keyword">if</span>(val[j]) print(j);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(last[j]) print(last[j]); <span class="comment">// 找到了！</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算fail函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">			f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 初始化队列</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA_SIZE; c++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> u = ch[<span class="number">0</span>][c];</span><br><span class="line">				<span class="keyword">if</span>(u)</span><br><span class="line">				&#123;</span><br><span class="line">					f[u] = <span class="number">0</span>;</span><br><span class="line">					q.push(u);</span><br><span class="line">					last[u] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 按BFS顺序计算fail</span></span><br><span class="line">			<span class="keyword">while</span>(!q.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> r = q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SIGMA_SIZE; c++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> u = ch[r][c];</span><br><span class="line">					<span class="keyword">if</span>(!u) <span class="keyword">continue</span>;</span><br><span class="line">					q.push(u);</span><br><span class="line">					<span class="keyword">int</span> v = f[r];</span><br><span class="line">					<span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v = f[v];</span><br><span class="line">					f[u] = ch[v][c];</span><br><span class="line">					last[u] = val[f[u]] ? f[u] : last[f[u]];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">AhoCorasickAutomata ac;</span><br><span class="line"><span class="keyword">char</span> text[<span class="number">1000001</span>], P[<span class="number">151</span>][<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		ac.init();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, P[i]);</span><br><span class="line">			ac.insert(P[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		ac.getFail();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span><br><span class="line">		ac.find(text);</span><br><span class="line">		<span class="keyword">int</span> best =  <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span>(ac.cnt[i] &gt; best) best = ac.cnt[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, best);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span>(ac.cnt[ms[<span class="built_in">string</span>(P[i])]] == best) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, P[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀排序/后缀数组(P221)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[MaxN] &#123; <span class="number">0</span> &#125;, x[MaxN] &#123; <span class="number">0</span> &#125;, y[MaxN] &#123; <span class="number">0</span> &#125;, c[MaxN] &#123; <span class="number">0</span> &#125;, n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSA</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		++c[x[i] = s[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		sa[--c[x[i]]] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - k; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			y[p++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sa[i] &gt;= k)</span><br><span class="line">			&#123;</span><br><span class="line">				y[p++] = sa[i] - k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			c[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			++c[x[y[i]]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::swap(x, y);</span><br><span class="line">		p = <span class="number">1</span>;</span><br><span class="line">		x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			x[sa[i]] = y[sa[i - <span class="number">1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k] ? p - <span class="number">1</span> : p++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p &gt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : s)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"></span><br><span class="line">	BuildSA(<span class="string">'z'</span> - <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sa[i] + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Block, n, q, Num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MaxN], b[MaxN], Belong[MaxN], Left[MaxN], Right[MaxN], Add[MaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Block = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(n));</span><br><span class="line">	Num = n / Block;</span><br><span class="line">	<span class="keyword">if</span> (n % Block)</span><br><span class="line">	&#123;</span><br><span class="line">		++Num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Belong[i] = (i - <span class="number">1</span>) / Block + <span class="number">1</span>;</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Num; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Left[i] = (i - <span class="number">1</span>) * Block + <span class="number">1</span>;</span><br><span class="line">		Right[i] = i * Block;</span><br><span class="line">	&#125;</span><br><span class="line">	Right[Num] = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Num; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::sort(b + Left[i], b + Right[i] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> Pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Left[Belong[Pos]]; i &lt;= Right[Belong[Pos]]; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::sort(b + Left[Belong[Pos]], b + Right[Belong[Pos]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Belong[l] == Belong[r])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] += Val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Reset(l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= Right[Belong[l]]; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] += Val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Left[Belong[r]]; i &lt;= r; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] += Val;</span><br><span class="line">		&#125;</span><br><span class="line">		Reset(l);</span><br><span class="line">		Reset(r);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Belong[l] + <span class="number">1</span>; i &lt; Belong[r]; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			Add[i] += Val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> Pos, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> l = Left[Pos], r = Right[Pos];</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[m] &lt; c)</span><br><span class="line">		&#123;</span><br><span class="line">			l = m + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			r = m - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Right[Pos] - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Belong[l] == Belong[r])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] + Add[Belong[l]] &gt;= c)</span><br><span class="line">			&#123;</span><br><span class="line">				++Ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= Right[Belong[l]]; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] + Add[Belong[i]] &gt;= c)</span><br><span class="line">			&#123;</span><br><span class="line">				++Ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Left[Belong[r]]; i &lt;= r; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] + Add[Belong[r]] &gt;= c)</span><br><span class="line">			&#123;</span><br><span class="line">				++Ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Belong[l] + <span class="number">1</span>; i &lt; Belong[r]; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			Ans += Find(i, c - Add[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Build();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'M'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, y, w;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">			Update(x, y, w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x, y, c;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Query(x, y, c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧拉回路（无向图）：P309(UVa10054)</span></span><br><span class="line"><span class="comment">// UVa10054 The Necklace</span></span><br><span class="line"><span class="comment">// Rujia Liu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> maxcolor = <span class="number">50</span>;</span><br><span class="line">		<span class="keyword">int</span> n, G[maxcolor+<span class="number">1</span>][maxcolor+<span class="number">1</span>], deg[maxcolor+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> from, to;</span><br><span class="line">		Edge(<span class="keyword">int</span> from, <span class="keyword">int</span> to):from(from),to(to) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= maxcolor; v++) <span class="keyword">if</span>(G[u][v])</span><br><span class="line">		&#123;</span><br><span class="line">			G[u][v]--;</span><br><span class="line">			G[v][u]--;</span><br><span class="line">			euler(v);</span><br><span class="line">			ans.push_back(Edge(u, v));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">		<span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(deg));</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u, v;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">			G[u][v]++;</span><br><span class="line">			G[v][u]++;</span><br><span class="line">			deg[u]++;</span><br><span class="line">			deg[v]++;</span><br><span class="line">			start = u;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 无向图的欧拉回路</span></span><br><span class="line">		<span class="keyword">bool</span> solved = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxcolor; i++)</span><br><span class="line">			<span class="keyword">if</span>(deg[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				solved = <span class="literal">false</span>;    <span class="comment">// 检查度数</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(solved)</span><br><span class="line">		&#123;</span><br><span class="line">			ans.clear();</span><br><span class="line">			euler(start);</span><br><span class="line">			<span class="keyword">if</span>(ans.size() != n || ans[<span class="number">0</span>].to != ans[ans.size()<span class="number">-1</span>].from) solved = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d\n"</span>, kase);</span><br><span class="line">		<span class="keyword">if</span>(!solved)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"some beads may be lost\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = ans.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[i].from, ans[i].to);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(kase &lt; T) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MaxN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, MaxN&gt; Pre &#123; <span class="number">0</span> &#125;, Low &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, MaxN&gt; IsCut &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, MaxN&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Clock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LowU = Pre[u] = ++Clock;</span><br><span class="line">	<span class="keyword">int</span> Child = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : G[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Pre[v])</span><br><span class="line">		&#123;</span><br><span class="line">			++Child;</span><br><span class="line">			<span class="keyword">auto</span> LowV = DFS(v, u);</span><br><span class="line">			LowU = <span class="built_in">std</span>::min(LowU, LowV);</span><br><span class="line">			<span class="keyword">if</span> (LowV &gt;= Pre[u])</span><br><span class="line">			&#123;</span><br><span class="line">				IsCut[u] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Pre[v] &lt; Pre[u] &amp;&amp; v != f)</span><br><span class="line">		&#123;</span><br><span class="line">			LowU = <span class="built_in">std</span>::min(LowU, Pre[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (f &lt; <span class="number">0</span> &amp;&amp; Child == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IsCut[u] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Low[u] = LowU;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		G[u].push_back(v);</span><br><span class="line">		G[v].push_back(u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Pre[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(i, <span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Tol = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (IsCut[i])</span><br><span class="line">		&#123;</span><br><span class="line">			++Tol;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Tol &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (IsCut[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>圆锥曲线-东风快递</title>
    <url>/2019/11/23/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF-%E4%B8%9C%E9%A3%8E%E5%BF%AB%E9%80%92/</url>
    <content><![CDATA[<h1 id="1-序言"><a href="#1-序言" class="headerlink" title="1.序言"></a>1.序言</h1><p>听名字就知道，本文要讲的是一些圆锥曲线的结论或计算技巧，能够有效加速解题效率。</p><h1 id="2-椭圆-sf-frac-x-2-a-2-frac-y-2-b-2-1"><a href="#2-椭圆-sf-frac-x-2-a-2-frac-y-2-b-2-1" class="headerlink" title="2.椭圆$\sf\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$"></a>2.椭圆$\sf\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$</h1><h2 id="1-对于-a-b-其中较大的一个所在的那个分数的分子所代表的轴就是椭圆的长轴"><a href="#1-对于-a-b-其中较大的一个所在的那个分数的分子所代表的轴就是椭圆的长轴" class="headerlink" title="1.对于$a$,$b$,其中较大的一个所在的那个分数的分子所代表的轴就是椭圆的长轴"></a>1.对于$a$,$b$,其中较大的一个所在的那个分数的分子所代表的轴就是椭圆的长轴</h2><h2 id="2-椭圆上点的性质"><a href="#2-椭圆上点的性质" class="headerlink" title="2.椭圆上点的性质"></a>2.椭圆上点的性质</h2><ul>
<li>到两焦点的距离和相等($\sf|PF_1|+|PF_2|=2a$)</li>
<li>到焦点和准线的距离比值一定($\sf\frac{\text{焦点距}}{\text{准线距}}=e$)</li>
<li>与两焦点连线的斜率之积为固定负值($\sf k_1k_2=-\frac{b^2}{a^2}$)</li>
</ul><a id="more"></a>

<p><img src="https://i.loli.net/2019/10/10/VacEM8XY4DyRqZC.png" alt="ZZNGR_3_AX_4SB57B_ZN_HS.png"></p>
<h2 id="3-焦半径的计算"><a href="#3-焦半径的计算" class="headerlink" title="3.焦半径的计算"></a>3.焦半径的计算</h2><h3 id="I-坐标法"><a href="#I-坐标法" class="headerlink" title="I.坐标法"></a>I.坐标法</h3><p>$\sf|PF_\text{左}|=a+ex_0$</p>
<p>$\sf|PF_\text{右}|=a-ex_0$</p>
<p>=&gt;两个分别以$\sf PF$为直径和长轴为直径的圆内切。</p>
<p><img src="https://i.loli.net/2019/10/10/MtOoXUTBS1fWbLE.png" alt="_BSFD_1RF_DN_HX47M_UOEA.png"></p>
<h3 id="II-极坐标法"><a href="#II-极坐标法" class="headerlink" title="II.极坐标法"></a>II.极坐标法</h3><p>$\sf|PF|=\frac{ep}{1-e\cos{\alpha}}$</p>
<p>焦半径的范围：[a-c,a+c]</p>
<p>$\sf||PF_1|-|PF_2||\leq2c$</p>
<h2 id="4-焦点弦的计算"><a href="#4-焦点弦的计算" class="headerlink" title="4.焦点弦的计算"></a>4.焦点弦的计算</h2><ul>
<li>坐标法：$\sf|AB|=|2a+e(x_1+x_2)|$</li>
<li>极坐标法：$\sf|AB|=\frac{2ep}{1-e^2\cos^2{\alpha}}$</li>
</ul>
<p>其中$\sf ep=\frac{b^2}{a}$，即半通径</p>
<h2 id="5-焦点弦的性质"><a href="#5-焦点弦的性质" class="headerlink" title="5.焦点弦的性质"></a>5.焦点弦的性质</h2><p>$\sf\frac{1}{|AF|}+\frac{1}{|BF|}=\frac{2}{ep}$</p>
<p>以焦点弦为直径的圆与最近的准线相离</p>
<p>做AB在准线上的投影，以这段投影为直径的圆与AB相离</p>
<p><img src="https://i.loli.net/2019/10/10/pHlXCkEBqsmyeO2.png" alt="0~DG04_M~7A_UX3Y_1XU44B.png"></p>
<h2 id="6-焦点三角形的面积"><a href="#6-焦点三角形的面积" class="headerlink" title="6.焦点三角形的面积"></a>6.焦点三角形的面积</h2><p>$\sf S=b^2\tan{\theta}=c*y_P$</p>
<p><img src="https://i.loli.net/2019/10/10/KncCdR4exGLuyfw.png" alt></p>
<h2 id="7-弦中点性质"><a href="#7-弦中点性质" class="headerlink" title="7.弦中点性质"></a>7.弦中点性质</h2><p>$\sf M=mid(A,B)$，则$\sf k_{AB}k_{OM}=-\frac{b^2}{a^2}$</p>
<h2 id="8-弦长公式"><a href="#8-弦长公式" class="headerlink" title="8.弦长公式"></a>8.弦长公式</h2><p>$\sf\begin{cases}y=mx+n\\sf\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\end{cases}$</p>
<p>$\Large\sf |AB|=\sqrt{m^2+1}*\frac{\sqrt{\frac{1}{a^2}+\frac{m^2}{b^2}-\frac{n^2}{a^2b^2}}}{\frac{1}{a^2}+\frac{m^2}{b^2}}$</p>
<p>$\sf\begin{cases}x=my+n\\sf\frac{x^2}{a^2}+\frac{y^2}{b^2}=1\end{cases}$</p>
<p>$\Large\sf |AB|=\sqrt{m^2+1}*\frac{\sqrt{\frac{m^2}{a^2}+\frac{1}{b^2}-\frac{n^2}{a^2b^2}}}{\frac{m^2}{a^2}+\frac{1}{b^2}}$</p>
<h2 id="8-极点极线"><a href="#8-极点极线" class="headerlink" title="8.极点极线"></a>8.极点极线</h2><ul>
<li>用$x_0x$换掉$x^2$，用$y_0y$换掉$y^2$</li>
<li>用$\sf\frac{x_0+x}{2}$换掉$x$，用$\sf\frac{y_0+y}{2}$换掉$y$</li>
</ul>
<p>即可得到极线(切点弦)</p>
<p>过椭圆外一点$P$做其弦$AB$，并作出其极线与$AB$交于$Q$，此时$A,B;P,Q$成<code>调和点列</code>。</p>
<p><img src="https://i.loli.net/2019/10/11/skRMdO4oX3YF1Cm.png" alt="0_C0_A13D_6_1X9G_L3Q75T.png"></p>
<h2 id="9-焦点弦三角形的性质"><a href="#9-焦点弦三角形的性质" class="headerlink" title="9.焦点弦三角形的性质"></a>9.焦点弦三角形的性质</h2><p><code>待补</code></p>
<p><img src="https://i.loli.net/2019/10/11/6iO7nS1wgU5HRqN.png" alt></p>
<hr>
<h1 id="2-双曲线-sf-frac-x-2-a-2-frac-y-2-b-2-1"><a href="#2-双曲线-sf-frac-x-2-a-2-frac-y-2-b-2-1" class="headerlink" title="2.双曲线$\sf\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$"></a>2.双曲线$\sf\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$</h1><h2 id="1-对于-a-b-其中为正的一个所在的那个分数的分子所代表的轴就是双曲线的实轴"><a href="#1-对于-a-b-其中为正的一个所在的那个分数的分子所代表的轴就是双曲线的实轴" class="headerlink" title="1.对于$a$,$b$,其中为正的一个所在的那个分数的分子所代表的轴就是双曲线的实轴"></a>1.对于$a$,$b$,其中为正的一个所在的那个分数的分子所代表的轴就是双曲线的实轴</h2><h2 id="2-双曲线上点的性质"><a href="#2-双曲线上点的性质" class="headerlink" title="2.双曲线上点的性质"></a>2.双曲线上点的性质</h2><ul>
<li>到两焦点的距离差的绝对值相等($\sf||PF_1|-|PF_2||=2a$)</li>
<li>到焦点和准线的距离比值一定($\sf\frac{\text{焦点距}}{\text{准线距}}=e$)</li>
</ul>
<p>此处有$\sf a^2+b^2=c^2$</p>
<p><img src="https://i.loli.net/2019/10/11/gAqQtjXDMHmcpUe.png" alt></p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title>博客_config.yml文件的配置</title>
    <url>/2019/11/23/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，我要在此恭喜一下自己，在大半年的不懈努力学习下，建站成功顺便学了一手html5。估计投入了约有40h的精力，但是由于操作失误导致其中的25h都是失败操作，意义不大。</p><p>为了防止大家出现无意义浪费时间的情况，我推了这则文章来简写一下<strong>博客根目录下</strong><code>_config.yml</code>文件的配置。</p><p>请注意：本博客内容将默认您已经成功安装hexo环境并且配置好了landscape默认主题。</p><a id="more"></a>


<p>根据提示，我们成功安装了hexo并关联好了博客文件夹，在<strong>根目录</strong>下打开<code>_config.yml</code>文件，就可以看见<strong>博客信息</strong>的相关配置了。</p>
<p><img src="https://i.loli.net/2019/11/17/vl32puDJyH5Kikt.png" alt></p>
<h2 id="基础信息配置："><a href="#基础信息配置：" class="headerlink" title="基础信息配置："></a>基础信息配置：</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">【网页标题】</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">【网页副标题】</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">【描述，可以是格言】</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">【关键字，便于搜索引擎爬取】</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">【作者名，就是您】</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">【主语言，简体中文是'zh-CN'】</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">【时区，不写即默认所在地】</span></span><br></pre></td></tr></table></figure>

<p>我配置完是这样的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">first's</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Just</span> <span class="string">Do</span> <span class="string">It,But</span> <span class="string">Not</span> <span class="string">Just</span> <span class="string">Do</span> <span class="string">It.</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">first_fan</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>

<p>作用部位在图中指出[指向’首页’是指’home’变成了中文的’首页’]</p>
<p><img src="https://i.loli.net/2019/11/17/yZkeuafx8DHFsRC.png" alt></p>
<h2 id="网址链接配置"><a href="#网址链接配置" class="headerlink" title="网址链接配置"></a>网址链接配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://firstfan119.github.io</span> <span class="string">【此处改为自己的域名】</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="string">【永久链接日期格式，非必要可以不改】</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing index.html from permalinks</span></span><br></pre></td></tr></table></figure>

<h2 id="写作配置"><a href="#写作配置" class="headerlink" title="写作配置"></a>写作配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="string">【新稿件的默认名】</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="string">【点击文章时在新标签页内打开】</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="string">【如果想在本标签页内打开请关闭】</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="string">【对整页有用】</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="string">【代码高光】</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="string">【是否开启】</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span> <span class="string">【行号显示】</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span> <span class="string">【自动检测】</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">''</span> <span class="string">【替换tab】</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>

<p>此处可以根据自己需要更改写作风格，我并未作大幅修改。</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="string">【我使用的是next主题】</span></span><br></pre></td></tr></table></figure>

<p>如果你下载了其他主题并已经将其放入themes文件夹中，则可以进行博客主题的选择，只要将名字更换为新主题名即可。</p>
<h2 id="其他细节配置"><a href="#其他细节配置" class="headerlink" title="其他细节配置"></a>其他细节配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span> <span class="string">【默认分类：未分类】</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span> <span class="string">【分类/标签地图，必要性不大】</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span> <span class="string">【日期格式设置，年月日是标准格式】</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span> <span class="string">【时分秒】</span></span><br><span class="line"><span class="comment">## Use post's date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这里是对于分类，标签的默认值配置以及对于时间格式的配置。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>动规递推式浅解</title>
    <url>/2019/11/23/%E5%8A%A8%E8%A7%84%E9%80%92%E6%8E%A8%E5%BC%8F%E6%B5%85%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>第一类斯特林数</li>
</ul><h3 id="f-n-k-f-n−1-k-∗-n−1-f-n−1-k−1"><a href="#f-n-k-f-n−1-k-∗-n−1-f-n−1-k−1" class="headerlink" title="f[n][k]=f[n−1][k]∗(n−1)+f[n−1][k−1]"></a>f[n][k]=f[n−1][k]∗(n−1)+f[n−1][k−1]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n个不同元素k个不同环，环不空</span><br></pre></td></tr></table></figure><ul>
<li>第二类斯特林数</li>
</ul><h3 id="f-n-k-f-n-1-k-k-f-n-1-k-1"><a href="#f-n-k-f-n-1-k-k-f-n-1-k-1" class="headerlink" title="f[n][k]=f[n-1][k]*k+f[n-1][k-1]"></a>f[n][k]=f[n-1][k]*k+f[n-1][k-1]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n个不同元素k个相同集，集不空</span><br></pre></td></tr></table></figure><ul>
<li>卡特兰数</li>
</ul><h3 id="f-n-f-n-1-4n-2-n-1"><a href="#f-n-f-n-1-4n-2-n-1" class="headerlink" title="f[n]=f[n-1]*(4n-2)/(n+1)"></a>f[n]=f[n-1]*(4n-2)/(n+1)</h3><h3 id="f-n-C-2n-n-n-1"><a href="#f-n-C-2n-n-n-1" class="headerlink" title="f[n]=$C^{2n}_{n}/(n+1)$"></a>f[n]=$C^{2n}_{n}/(n+1)$</h3><a id="more"></a>






<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n对括号，正确匹配方案数</span><br><span class="line">n个节点，二叉树构造方案数</span><br><span class="line">n边形，凸多边形划分为三角形方案数</span><br><span class="line">n个元素，出栈序列种数</span><br><span class="line"><span class="number">2</span>n的(<span class="number">-1</span>,<span class="number">1</span>)序列，使任意前缀非负的方案数</span><br></pre></td></tr></table></figure>

<ul>
<li>01背包</li>
</ul>
<h3 id="f-i-j-sum-max-min-f-i-1-j-f-i-1-j-w-k-v-k"><a href="#f-i-j-sum-max-min-f-i-1-j-f-i-1-j-w-k-v-k" class="headerlink" title="f[i][j]=sum/max/min(f[i-1][j],f[i-1][j-w[k]]+v[k])"></a>f[i][j]=sum/max/min(f[i-1][j],f[i-1][j-w[k]]+v[k])</h3><ul>
<li>多重背包</li>
</ul>
<h3 id="f-i-j-sum-max-min-f-i-2-p-j-f-i-2-p-j-w-k-p-v-k-p"><a href="#f-i-j-sum-max-min-f-i-2-p-j-f-i-2-p-j-w-k-p-v-k-p" class="headerlink" title="f[i][j]=sum/max/min(f[i-2^p][j],f[i-2^p][j-w[k][p]]+v[k][p])"></a>f[i][j]=sum/max/min(f[i-2^p][j],f[i-2^p][j-w[k][p]]+v[k][p])</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">把物品二进制拆分成很多个物品，倍增思想</span><br></pre></td></tr></table></figure>

<ul>
<li>区间动规</li>
</ul>
<h3 id="f-i-j-sum-max-min-f-i-k-f-k-1-j-g-i-j"><a href="#f-i-j-sum-max-min-f-i-k-f-k-1-j-g-i-j" class="headerlink" title="f[i][j]=sum/max/min(f[i][k]+f[k+1][j]+g(i,j))"></a>f[i][j]=sum/max/min(f[i][k]+f[k+1][j]+g(i,j))</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k为断点,g(i,j)为[i,j]区间相关代价函数</span><br><span class="line">枚举断点进行递推</span><br><span class="line">常见于合并区间，回文对应，左右子树配对等</span><br></pre></td></tr></table></figure>

<ul>
<li>树形动规</li>
</ul>
<h3 id="f-i-j-sum-max-min-sum-k∈son-i-f-k-g-j"><a href="#f-i-j-sum-max-min-sum-k∈son-i-f-k-g-j" class="headerlink" title="f[i][j]=sum/max/min($\sum_{k∈son_i}f[k][g(j)]$)"></a>f[i][j]=sum/max/min($\sum_{k∈son_i}f[k][g(j)]$)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g(j)是关于状态j的函数，通常是<span class="number">0</span>/<span class="number">1</span></span><br><span class="line">表示选不选，染什么色，左儿子还是右儿子等等</span><br><span class="line">常见于树形分组背包，树的直径，树上<span class="number">01</span>问题等</span><br></pre></td></tr></table></figure>

<ul>
<li>状压动规</li>
</ul>
<h3 id="f-i-j-k-sum-max-min-sum-p∈S-j-f-i-1-p-k-1"><a href="#f-i-j-k-sum-max-min-sum-p∈S-j-f-i-1-p-k-1" class="headerlink" title="f[i][j][k]=sum/max/min($\sum_{p∈S(j)}$f[i-1][p][k-1])"></a>f[i][j][k]=sum/max/min($\sum_{p∈S(j)}$f[i-1][p][k-1])</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i,j,k:行数,状态,数量</span><br><span class="line">S(j)为与j状态能够相容的状态集合</span><br><span class="line">可以转化为类<span class="number">01</span>背包问题</span><br><span class="line">往往用于合法放置方案数问题</span><br></pre></td></tr></table></figure>

<ul>
<li>单调队列优化式</li>
</ul>
<h3 id="f-i-min-max-sum-j-i-m-1-i-a-j"><a href="#f-i-min-max-sum-j-i-m-1-i-a-j" class="headerlink" title="f[i]=min/max$\sum_{j=i-m+1}^{i}$a[j]"></a>f[i]=min/max$\sum_{j=i-m+1}^{i}$a[j]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">序列中长为m的滑动窗口最值问题</span><br><span class="line">最大连续和，定长连续子区间最值</span><br><span class="line">队列滚维</span><br></pre></td></tr></table></figure>

<ul>
<li>斜率优化式</li>
</ul>
<h3 id="f-i-min-f-j-g-i-g-j-2"><a href="#f-i-min-f-j-g-i-g-j-2" class="headerlink" title="f[i]=min{f[j]+(g(i)-g(j))$^2$}"></a>f[i]=min{f[j]+(g(i)-g(j))$^2$}</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">下标为横，值为纵，构造斜率。</span><br><span class="line">单调队列维护下凸壳。</span><br><span class="line">如果凸壳需要动态化，使用平衡树插入/删除维护下凸即可</span><br></pre></td></tr></table></figure>

<ul>
<li>目前整理内容均比较粗略，后续会进行补充。</li>
</ul>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划入门</title>
    <url>/2019/11/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h2 id="1-从乘方和谚语说起"><a href="#1-从乘方和谚语说起" class="headerlink" title="1. 从乘方和谚语说起"></a>1. 从乘方和谚语说起</h2><h2 id="2-斐波那契数列：递归受到了挑战"><a href="#2-斐波那契数列：递归受到了挑战" class="headerlink" title="2. 斐波那契数列：递归受到了挑战"></a>2. 斐波那契数列：递归受到了挑战</h2><h2 id="3-动态规划的原理"><a href="#3-动态规划的原理" class="headerlink" title="3. 动态规划的原理"></a>3. 动态规划的原理</h2><h3 id="–3-1最优子结构"><a href="#–3-1最优子结构" class="headerlink" title="–3.1最优子结构"></a>–3.1最优子结构</h3><h3 id="–3-2重叠子问题"><a href="#–3-2重叠子问题" class="headerlink" title="–3.2重叠子问题"></a>–3.2重叠子问题</h3><h2 id="4-动态规划的应用"><a href="#4-动态规划的应用" class="headerlink" title="4.动态规划的应用"></a>4.动态规划的应用</h2><h3 id="–4-1背包模型"><a href="#–4-1背包模型" class="headerlink" title="–4.1背包模型"></a>–4.1背包模型</h3><h5 id="–4-1-1-零一背包"><a href="#–4-1-1-零一背包" class="headerlink" title="–4.1.1 零一背包"></a>–4.1.1 零一背包</h5><h5 id="–4-1-2-完全背包"><a href="#–4-1-2-完全背包" class="headerlink" title="–4.1.2 完全背包"></a>–4.1.2 完全背包</h5><h5 id="–4-1-3-多重背包"><a href="#–4-1-3-多重背包" class="headerlink" title="–4.1.3 多重背包"></a>–4.1.3 多重背包</h5><h3 id="–4-2线性动规"><a href="#–4-2线性动规" class="headerlink" title="–4.2线性动规"></a>–4.2线性动规</h3><h3 id="–4-3区间动规"><a href="#–4-3区间动规" class="headerlink" title="–4.3区间动规"></a>–4.3区间动规</h3><h2 id="5-入土"><a href="#5-入土" class="headerlink" title="5.入土"></a>5.入土</h2><hr><h1 id="1-从乘方和谚语说起-1"><a href="#1-从乘方和谚语说起-1" class="headerlink" title="1.从乘方和谚语说起"></a>1.从乘方和谚语说起</h1><h2 id="相信你们都学习过乘方，那么我们知道"><a href="#相信你们都学习过乘方，那么我们知道" class="headerlink" title="相信你们都学习过乘方，那么我们知道:"></a>相信你们都学习过乘方，那么我们知道:</h2><a id="more"></a>
<h3 id="2-X-2-X-2-X-2-X-2-X-2-X-2-X-2-X-2-X-2-2-10-1024"><a href="#2-X-2-X-2-X-2-X-2-X-2-X-2-X-2-X-2-X-2-2-10-1024" class="headerlink" title="2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 =2^10=1024"></a>2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 =2^10=1024</h3><h3 id="那么2-11是多少呢？你会自然而然地答出2048"><a href="#那么2-11是多少呢？你会自然而然地答出2048" class="headerlink" title="那么2^11是多少呢？你会自然而然地答出2048!"></a>那么2^11是多少呢？你会自然而然地答出2048!</h3><h3 id="好的，祝贺你已经学会了动规初步！"><a href="#好的，祝贺你已经学会了动规初步！" class="headerlink" title="好的，祝贺你已经学会了动规初步！"></a>好的，祝贺你已经学会了动规初步！</h3><h1 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h1><h3 id="我们作为人，计算2-11自然不是2X2……X2-2048这样算的"><a href="#我们作为人，计算2-11自然不是2X2……X2-2048这样算的" class="headerlink" title="我们作为人，计算2^11自然不是2X2……X2=2048这样算的"></a>我们作为人，计算2^11自然不是2X2……X2=2048这样算的</h3><h3 id="而是通过已经给出的2-10-1024计算的：2X1024-2048。"><a href="#而是通过已经给出的2-10-1024计算的：2X1024-2048。" class="headerlink" title="而是通过已经给出的2^10=1024计算的：2X1024=2048。"></a>而是通过已经给出的2^10=1024计算的：2X1024=2048。</h3><h3 id="这个过程就包括了动规的核心思想之一："><a href="#这个过程就包括了动规的核心思想之一：" class="headerlink" title="这个过程就包括了动规的核心思想之一："></a>这个过程就包括了动规的核心思想之一：</h3><h3 id="记住子问题的解。"><a href="#记住子问题的解。" class="headerlink" title="记住子问题的解。"></a>记住子问题的解。</h3><h3 id="一句谚语解释："><a href="#一句谚语解释：" class="headerlink" title="一句谚语解释："></a>一句谚语解释：</h3><h5 id="Those-who-cannot-remember-the-past-are-doomed-to-repeat-it-–George-Santayana"><a href="#Those-who-cannot-remember-the-past-are-doomed-to-repeat-it-–George-Santayana" class="headerlink" title="Those who cannot remember the past, are doomed to repeat it.–George Santayana"></a>Those who cannot remember the past, are doomed to repeat it.–George Santayana</h5><h5 id="那些忘记过去的人注定要重蹈覆辙。"><a href="#那些忘记过去的人注定要重蹈覆辙。" class="headerlink" title="那些忘记过去的人注定要重蹈覆辙。"></a>那些忘记过去的人注定要重蹈覆辙。</h5><hr>
<h1 id="2-斐波那契数列：递归受到了挑战-1"><a href="#2-斐波那契数列：递归受到了挑战-1" class="headerlink" title="2. 斐波那契数列：递归受到了挑战"></a>2. 斐波那契数列：递归受到了挑战</h1><h2 id="对于斐波那契数列的求解，递归往往是最先考虑的解法，但是在1000ms的苛求下，递归O-2-n-的时间复杂度就比较麻烦了。"><a href="#对于斐波那契数列的求解，递归往往是最先考虑的解法，但是在1000ms的苛求下，递归O-2-n-的时间复杂度就比较麻烦了。" class="headerlink" title="对于斐波那契数列的求解，递归往往是最先考虑的解法，但是在1000ms的苛求下，递归O(2^n)的时间复杂度就比较麻烦了。"></a>对于斐波那契数列的求解，递归往往是最先考虑的解法，但是在1000ms的苛求下，递归O(2^n)的时间复杂度就比较麻烦了。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//递归解斐波那契</span><br><span class="line">long long Fib(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n==1||n==2)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return Fib(n - 1) + Fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解?"></a>图解?</h3><p><img src="https://upload-images.jianshu.io/upload_images/13681871-5e793aa7d967f719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp" alt></p>
<h3 id="从图中可以看到，光是算fib-6-，就要重新算3遍fib-3-，时间复杂度就比较恶心了。对了，你想起什么没有？记住子问题的答案–动规登场！"><a href="#从图中可以看到，光是算fib-6-，就要重新算3遍fib-3-，时间复杂度就比较恶心了。对了，你想起什么没有？记住子问题的答案–动规登场！" class="headerlink" title="从图中可以看到，光是算fib(6)，就要重新算3遍fib(3)，时间复杂度就比较恶心了。对了，你想起什么没有？记住子问题的答案–动规登场！"></a>从图中可以看到，光是算fib(6)，就要重新算3遍fib(3)，时间复杂度就比较恶心了。对了，你想起什么没有？记住子问题的答案–动规登场！</h3><h4 id="1-子问题记忆法"><a href="#1-子问题记忆法" class="headerlink" title="1.子问题记忆法"></a>1.子问题记忆法</h4><h5 id="使用一个数组来记录各个子问题的解，当再一次遇到这一问题的时候直接查找数组来获得解避免多次计算子问题。"><a href="#使用一个数组来记录各个子问题的解，当再一次遇到这一问题的时候直接查找数组来获得解避免多次计算子问题。" class="headerlink" title="使用一个数组来记录各个子问题的解，当再一次遇到这一问题的时候直接查找数组来获得解避免多次计算子问题。"></a>使用一个数组来记录各个子问题的解，当再一次遇到这一问题的时候直接查找数组来获得解避免多次计算子问题。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动规解决斐波那契(子问题记忆法)</span><br><span class="line">int fib(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[n] &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    a[n] = fib(a, n - 1) + fib(a, n - 2);</span><br><span class="line">    return fib(a, n - 1) + fib(a, n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、自底向上解决方案"><a href="#2、自底向上解决方案" class="headerlink" title="2、自底向上解决方案"></a>2、自底向上解决方案</h4><h5 id="先求解子问题再根据子问题的解来求解父问题，斐波那契数列的子问题图如下："><a href="#先求解子问题再根据子问题的解来求解父问题，斐波那契数列的子问题图如下：" class="headerlink" title="先求解子问题再根据子问题的解来求解父问题，斐波那契数列的子问题图如下："></a>先求解子问题再根据子问题的解来求解父问题，斐波那契数列的子问题图如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动规解决斐波那契(自底向上解决)</span><br><span class="line">int fib(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    a[0] = 0;</span><br><span class="line">    a[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = a[i - 1] + a[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自底向上的计算方法实现起来非常容易，分析算法，仅从形式上面分析算法可知，算法的时间主要消耗在计算数据规模为n的数组里面的数上面了，所以时间复杂度仅为-color-red-text-O-n-。递归在斐波那契的地位不保了！！"><a href="#自底向上的计算方法实现起来非常容易，分析算法，仅从形式上面分析算法可知，算法的时间主要消耗在计算数据规模为n的数组里面的数上面了，所以时间复杂度仅为-color-red-text-O-n-。递归在斐波那契的地位不保了！！" class="headerlink" title="自底向上的计算方法实现起来非常容易，分析算法，仅从形式上面分析算法可知，算法的时间主要消耗在计算数据规模为n的数组里面的数上面了，所以时间复杂度仅为:$\color{red}\text{O(n)}$。递归在斐波那契的地位不保了！！"></a>自底向上的计算方法实现起来非常容易，分析算法，仅从形式上面分析算法可知，算法的时间主要消耗在计算数据规模为n的数组里面的数上面了，所以时间复杂度仅为:$\color{red}\text{O(n)}$。递归在斐波那契的地位不保了！！</h4><h3 id="但是我们可以看到，在使用动规的时候，我们似乎多开了一个数组，那么空间是否会受到影响？答案是肯定的！但是在1000ms-256Mb的条件下，牺牲空间换取时间绝对是一笔很值的交♂易！"><a href="#但是我们可以看到，在使用动规的时候，我们似乎多开了一个数组，那么空间是否会受到影响？答案是肯定的！但是在1000ms-256Mb的条件下，牺牲空间换取时间绝对是一笔很值的交♂易！" class="headerlink" title="但是我们可以看到，在使用动规的时候，我们似乎多开了一个数组，那么空间是否会受到影响？答案是肯定的！但是在1000ms,256Mb的条件下，牺牲空间换取时间绝对是一笔很值的交♂易！"></a>但是我们可以看到，在使用动规的时候，我们似乎多开了一个数组，那么空间是否会受到影响？答案是肯定的！但是在1000ms,256Mb的条件下，牺牲空间换取时间绝对是一笔很值的交♂易！</h3><h3 id="练习-LuoGu3986-amp-钢条切割"><a href="#练习-LuoGu3986-amp-钢条切割" class="headerlink" title="练习:LuoGu3986&amp;钢条切割"></a>练习:<a href="https://www.luogu.org/problemnew/show/P3986" target="_blank" rel="noopener">LuoGu3986</a>&amp;<a href="https://www.cnblogs.com/mengwang024/p/4342796.html" target="_blank" rel="noopener">钢条切割</a></h3><hr>
<h1 id="3-动态规划的原理-1"><a href="#3-动态规划的原理-1" class="headerlink" title="3.动态规划的原理"></a>3.动态规划的原理</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><h4 id="用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。"><a href="#用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。" class="headerlink" title="用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。"></a>用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。</h4><h2 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h2><h4 id="在斐波拉契和钢条切割中，可以看到大量的重叠子问题，比如说在求fib-6-的时候，fib-2-被调用了5次。如果使用递归算法的时候会反复求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题性质。在动态规划算法中使用数组来保存子问题的解，问题多次求解的时候可以直接查表不用调用函数递归。"><a href="#在斐波拉契和钢条切割中，可以看到大量的重叠子问题，比如说在求fib-6-的时候，fib-2-被调用了5次。如果使用递归算法的时候会反复求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题性质。在动态规划算法中使用数组来保存子问题的解，问题多次求解的时候可以直接查表不用调用函数递归。" class="headerlink" title="在斐波拉契和钢条切割中，可以看到大量的重叠子问题，比如说在求fib(6)的时候，fib(2)被调用了5次。如果使用递归算法的时候会反复求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题性质。在动态规划算法中使用数组来保存子问题的解，问题多次求解的时候可以直接查表不用调用函数递归。"></a>在斐波拉契和钢条切割中，可以看到大量的重叠子问题，比如说在求fib(6)的时候，fib(2)被调用了5次。如果使用递归算法的时候会反复求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题性质。在动态规划算法中使用数组来保存子问题的解，问题多次求解的时候可以直接查表不用调用函数递归。</h4><h2 id="简单来说，动规就是递归再加上记录。"><a href="#简单来说，动规就是递归再加上记录。" class="headerlink" title="简单来说，动规就是递归再加上记录。"></a>简单来说，动规就是递归再加上记录。</h2><h2 id="花小部分空间，省大部分时间。"><a href="#花小部分空间，省大部分时间。" class="headerlink" title="花小部分空间，省大部分时间。"></a>花小部分空间，省大部分时间。</h2><hr>
<h1 id="4-动态规划的应用-1"><a href="#4-动态规划的应用-1" class="headerlink" title="4.动态规划的应用"></a>4.动态规划的应用</h1><h2 id="4-1背包问题"><a href="#4-1背包问题" class="headerlink" title="4.1背包问题"></a>4.1背包问题</h2><h2 id="1-零一背包"><a href="#1-零一背包" class="headerlink" title="1.零一背包"></a>1.零一背包</h2><h4 id="有N件物品和一个容量为V的背包。第i件物品的体积是w-i-，价值是c-i-。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，每个物品只能选用一次-使得价值总和最大。"><a href="#有N件物品和一个容量为V的背包。第i件物品的体积是w-i-，价值是c-i-。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，每个物品只能选用一次-使得价值总和最大。" class="headerlink" title="有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，每个物品只能选用一次,使得价值总和最大。"></a>有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，每个物品只能选用一次,使得价值总和最大。</h4><h4 id="这是最基础的背包问题，总的来说就是：选还是不选"><a href="#这是最基础的背包问题，总的来说就是：选还是不选" class="headerlink" title="这是最基础的背包问题，总的来说就是：选还是不选"></a>这是最基础的背包问题，总的来说就是：选还是不选</h4><h3 id="例题-LuoGu1048"><a href="#例题-LuoGu1048" class="headerlink" title="例题:LuoGu1048"></a>例题:<a href="https://www.luogu.org/problemnew/show/P1048" target="_blank" rel="noopener">LuoGu1048</a></h3><h3 id="显然，这道题并不能用贪心，因为假设你要在100时间内采药，有三个药：71时间，89价值；30时间，44价值；40时间，45价值。如果是贪心，就会果断选-71-89-，但事实上-30-44-和-40-45-更优。此时请出动规，怎么用呢？"><a href="#显然，这道题并不能用贪心，因为假设你要在100时间内采药，有三个药：71时间，89价值；30时间，44价值；40时间，45价值。如果是贪心，就会果断选-71-89-，但事实上-30-44-和-40-45-更优。此时请出动规，怎么用呢？" class="headerlink" title="显然，这道题并不能用贪心，因为假设你要在100时间内采药，有三个药：71时间，89价值；30时间，44价值；40时间，45价值。如果是贪心，就会果断选(71,89)，但事实上(30,44)和(40,45)更优。此时请出动规，怎么用呢？"></a>显然，这道题并不能用贪心，因为假设你要在100时间内采药，有三个药：71时间，89价值；30时间，44价值；40时间，45价值。如果是贪心，就会果断选(71,89)，但事实上(30,44)和(40,45)更优。此时请出动规，怎么用呢？</h3><h3 id="列出状态转移方程"><a href="#列出状态转移方程" class="headerlink" title="列出状态转移方程!"></a>列出状态转移方程!</h3><h3 id="对于一个物品，只有两种情况"><a href="#对于一个物品，只有两种情况" class="headerlink" title="对于一个物品，只有两种情况"></a>对于一个物品，只有两种情况</h3><h4 id="1-第i件不放进去，这时所得价值为-dp-i-1-v"><a href="#1-第i件不放进去，这时所得价值为-dp-i-1-v" class="headerlink" title="1.第i件不放进去，这时所得价值为:dp[i-1][v]"></a>1.第i件不放进去，这时所得价值为:dp[i-1][v]</h4><h4 id="2-第i件放进去，这时所得价值为-dp-i-1-v-c-i-w-i"><a href="#2-第i件放进去，这时所得价值为-dp-i-1-v-c-i-w-i" class="headerlink" title="2.第i件放进去，这时所得价值为:dp[i-1][v-c[i]]+w[i]"></a>2.第i件放进去，这时所得价值为:dp[i-1][v-c[i]]+w[i]</h4><h3 id="故状态转移方程为"><a href="#故状态转移方程为" class="headerlink" title="故状态转移方程为:"></a>故状态转移方程为:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][v] = max(dp[i-1][v], dp[i-1][v-w[i]]+c[i])</span><br></pre></td></tr></table></figure>
<h5 id="注-零一背包可以用一维数组记录最优计划dp-v-表示不超过v体积的最大价值。"><a href="#注-零一背包可以用一维数组记录最优计划dp-v-表示不超过v体积的最大价值。" class="headerlink" title="注:零一背包可以用一维数组记录最优计划dp[v],表示不超过v体积的最大价值。"></a>注:零一背包可以用一维数组记录最优计划dp[v],表示不超过v体积的最大价值。</h5><h4 id="背包退火-了解一下？"><a href="#背包退火-了解一下？" class="headerlink" title="背包退火?了解一下？"></a><a href="https://www.luogu.org/blog/firstfan/post-shi-yan-shi-ep1-bei-bao-tui-huo-post" target="_blank" rel="noopener">背包退火</a>?了解一下？</h4><h2 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2.完全背包"></a>2.完全背包</h2><h4 id="有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是w-i-，价值是c-i-。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。"><a href="#有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是w-i-，价值是c-i-。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。" class="headerlink" title="有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。"></a>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</h4><h4 id="完全背包和01背包十分相像，-区别就是完全背包物品有无限件。总的来说就是选还是不选，选几件。"><a href="#完全背包和01背包十分相像，-区别就是完全背包物品有无限件。总的来说就是选还是不选，选几件。" class="headerlink" title="完全背包和01背包十分相像， 区别就是完全背包物品有无限件。总的来说就是选还是不选，选几件。"></a>完全背包和01背包十分相像， 区别就是完全背包物品有无限件。总的来说就是选还是不选，选几件。</h4><h3 id="例题：LuoGu1616"><a href="#例题：LuoGu1616" class="headerlink" title="例题：LuoGu1616"></a>例题：<a href="https://www.luogu.org/problemnew/show/P1616" target="_blank" rel="noopener">LuoGu1616</a></h3><h3 id="列出状态转移方程-1"><a href="#列出状态转移方程-1" class="headerlink" title="列出状态转移方程"></a>列出状态转移方程</h3><h4 id="若不采这种草药，则时间花费没有增多-经过的-草药种数增加了1-采到草药价格不变-所以-dp-i-j-dp-i-1-j"><a href="#若不采这种草药，则时间花费没有增多-经过的-草药种数增加了1-采到草药价格不变-所以-dp-i-j-dp-i-1-j" class="headerlink" title="若不采这种草药，则时间花费没有增多,经过的 草药种数增加了1,采到草药价格不变,所以 dp[i][j]=dp[i-1][j];"></a>若不采这种草药，则时间花费没有增多,经过的 草药种数增加了1,采到草药价格不变,所以 dp[i][j]=dp[i-1][j];</h4><h4 id="若采这种草药-则-时间花费增加了t-i-种数增加1-采到草药价格增加了p-i-所以-dp-i-j-dp-i-1-j-t-i-p-i-。"><a href="#若采这种草药-则-时间花费增加了t-i-种数增加1-采到草药价格增加了p-i-所以-dp-i-j-dp-i-1-j-t-i-p-i-。" class="headerlink" title="若采这种草药,则 时间花费增加了t[i],种数增加1,采到草药价格增加了p[i],所以 dp[i][j]=dp[i-1][j-t[i]]+p[i]。"></a>若采这种草药,则 时间花费增加了t[i],种数增加1,采到草药价格增加了p[i],所以 dp[i][j]=dp[i-1][j-t[i]]+p[i]。</h4><h4 id="我们要使dp-i-j-color-red-text-尽可能大-即"><a href="#我们要使dp-i-j-color-red-text-尽可能大-即" class="headerlink" title="我们要使dp[i][j]$\color{red}\text{尽可能大}$,即?"></a>我们要使dp[i][j]$\color{red}\text{尽可能大}$,即?</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j]=max(dp[i-1][j],f[i-1][j-t[i]]+p[i])</span><br></pre></td></tr></table></figure>
<h3 id="这道题对于药就没有限制了，每种都无限多，所以优化出现了："><a href="#这道题对于药就没有限制了，每种都无限多，所以优化出现了：" class="headerlink" title="这道题对于药就没有限制了，每种都无限多，所以优化出现了："></a>这道题对于药就没有限制了，每种都无限多，所以优化出现了：</h3><h4 id="当一个药品的价值小于另一个药品的价值，并且时间高于另一个药品，我们就可以不去考虑这个药品。既然我们不是地主家的傻孩子，为什么还要花更多的时间采更少价值的药呢"><a href="#当一个药品的价值小于另一个药品的价值，并且时间高于另一个药品，我们就可以不去考虑这个药品。既然我们不是地主家的傻孩子，为什么还要花更多的时间采更少价值的药呢" class="headerlink" title="当一个药品的价值小于另一个药品的价值，并且时间高于另一个药品，我们就可以不去考虑这个药品。既然我们不是地主家的傻孩子，为什么还要花更多的时间采更少价值的药呢??"></a>当一个药品的价值小于另一个药品的价值，并且时间高于另一个药品，我们就可以不去考虑这个药品。既然我们不是地主家的傻孩子，为什么还要花更多的时间采更少价值的药呢??</h4><h5 id="注-该问题也可以压缩到一维最优计划dp-v-我们可以将药的种类i省略-，用后面算的值覆盖掉前面算的值"><a href="#注-该问题也可以压缩到一维最优计划dp-v-我们可以将药的种类i省略-，用后面算的值覆盖掉前面算的值" class="headerlink" title="注:该问题也可以压缩到一维最优计划dp[v],我们可以将药的种类i省略 ，用后面算的值覆盖掉前面算的值."></a>注:该问题也可以压缩到一维最优计划dp[v],我们可以将药的种类i省略 ，用后面算的值覆盖掉前面算的值.</h5><h4 id="巨佬们，背包退火-了解一下？"><a href="#巨佬们，背包退火-了解一下？" class="headerlink" title="巨佬们，背包退火?了解一下？"></a>巨佬们，<a href="https://www.luogu.org/blog/firstfan/post-shi-yan-shi-ep1-bei-bao-tui-huo-post" target="_blank" rel="noopener">背包退火</a>?了解一下？</h4><h2 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3.多重背包"></a>3.多重背包</h2><h4 id="有N种物品和一个容量为V的背包。第i种物品有n-i-个可用，每件费用是w-i-，价值是c-i-。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。"><a href="#有N种物品和一个容量为V的背包。第i种物品有n-i-个可用，每件费用是w-i-，价值是c-i-。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。" class="headerlink" title="有N种物品和一个容量为V的背包。第i种物品有n[i]个可用，每件费用是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。"></a>有N种物品和一个容量为V的背包。第i种物品有n[i]个可用，每件费用是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</h4><h4 id="这里又多了一个限制条件，每个物品规定了可用的次数。"><a href="#这里又多了一个限制条件，每个物品规定了可用的次数。" class="headerlink" title="这里又多了一个限制条件，每个物品规定了可用的次数。"></a>这里又多了一个限制条件，每个物品规定了可用的次数。</h4><h3 id="例题：LuoGu2347"><a href="#例题：LuoGu2347" class="headerlink" title="例题：LuoGu2347"></a>例题：<a href="https://www.luogu.org/problemnew/show/P2347" target="_blank" rel="noopener">LuoGu2347</a></h3><h5 id="我才不会告诉你我把多重背包拆成01背包来做的呢"><a href="#我才不会告诉你我把多重背包拆成01背包来做的呢" class="headerlink" title="我才不会告诉你我把多重背包拆成01背包来做的呢"></a><del>我才不会告诉你我把多重背包拆成01背包来做的呢</del></h5><h4 id="没错，对于一般的多重背包，换成01背包水就行了，至于不一般的嘛……则可以利用倍增思想把2-i个该物品用心的一个捆绑包表示出来。"><a href="#没错，对于一般的多重背包，换成01背包水就行了，至于不一般的嘛……则可以利用倍增思想把2-i个该物品用心的一个捆绑包表示出来。" class="headerlink" title="没错，对于一般的多重背包，换成01背包水就行了，至于不一般的嘛……则可以利用倍增思想把2^i个该物品用心的一个捆绑包表示出来。"></a>没错，对于一般的多重背包，换成01背包水就行了，至于不一般的嘛……则可以利用倍增思想把2^i个该物品用心的一个捆绑包表示出来。</h4><h3 id="列出状态转移方程-2"><a href="#列出状态转移方程-2" class="headerlink" title="列出状态转移方程"></a>列出状态转移方程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][v]=max(f[i-1][v-k*w[i]]+ k*c[i]|0&lt;=k&lt;=n[i])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-2线性动规"><a href="#4-2线性动规" class="headerlink" title="4.2线性动规"></a>4.2线性动规</h2><h3 id="其实线性动规是动规中较简单的一类题目，重点有三："><a href="#其实线性动规是动规中较简单的一类题目，重点有三：" class="headerlink" title="其实线性动规是动规中较简单的一类题目，重点有三："></a>其实线性动规是动规中较简单的一类题目，重点有三：</h3><h2 id="1-选对算法，正确维护"><a href="#1-选对算法，正确维护" class="headerlink" title="1.选对算法，正确维护"></a>1.选对算法，正确维护</h2><h3 id="例题-LuoGu1115"><a href="#例题-LuoGu1115" class="headerlink" title="例题:LuoGu1115"></a>例题:<a href="https://www.luogu.org/problemnew/show/P1115" target="_blank" rel="noopener">LuoGu1115</a></h3><h2 id="2-巧妙利用前缀和"><a href="#2-巧妙利用前缀和" class="headerlink" title="2.巧妙利用前缀和"></a>2.巧妙利用前缀和</h2><h3 id="例题-LuoGu1387"><a href="#例题-LuoGu1387" class="headerlink" title="例题:LuoGu1387"></a>例题:<a href="https://www.luogu.org/problemnew/show/P1387" target="_blank" rel="noopener">LuoGu1387</a></h3><h2 id="3-别忘了合理递推"><a href="#3-别忘了合理递推" class="headerlink" title="3.别忘了合理递推"></a>3.别忘了合理递推</h2><h3 id="例题-LuoGu1052"><a href="#例题-LuoGu1052" class="headerlink" title="例题:LuoGu1052"></a>例题:<a href="https://www.luogu.org/problemnew/show/P1052" target="_blank" rel="noopener">LuoGu1052</a></h3><h4 id="线性递归的题个人觉得要多练，所以放了几道题，希望在刷题的过程中，你能够领悟其精髓。同时，你可以参考一个近乎万能的线性模板博客-线性动态规划"><a href="#线性递归的题个人觉得要多练，所以放了几道题，希望在刷题的过程中，你能够领悟其精髓。同时，你可以参考一个近乎万能的线性模板博客-线性动态规划" class="headerlink" title="线性递归的题个人觉得要多练，所以放了几道题，希望在刷题的过程中，你能够领悟其精髓。同时，你可以参考一个近乎万能的线性模板博客?线性动态规划"></a>线性递归的题个人觉得要多练，所以放了几道题，希望在刷题的过程中，你能够领悟其精髓。同时，你可以参考一个近乎万能的线性模板博客?<a href="https://blog.csdn.net/weixin_40317006/article/details/81195479" target="_blank" rel="noopener">线性动态规划</a></h4><hr>
<h2 id="4-3区间动规"><a href="#4-3区间动规" class="headerlink" title="4.3区间动规"></a>4.3区间动规</h2><h3 id="例题-LuoGu1435"><a href="#例题-LuoGu1435" class="headerlink" title="例题:LuoGu1435"></a>例题:<a href="https://www.luogu.org/problemnew/show/P1435" target="_blank" rel="noopener">LuoGu1435</a></h3><h4 id="典型的区间模型，回文串拥有很明显的子结构特征，即当字符串s是一个回文串时，在X两边各添加一个字符’a’后，a-s-a仍然是一个回文串，我们用d-i-j-来表示A-i…j-这个子串变成回文串所需要添加的最少的字符数，那么对于A-i-A-j-的情况，很明显有"><a href="#典型的区间模型，回文串拥有很明显的子结构特征，即当字符串s是一个回文串时，在X两边各添加一个字符’a’后，a-s-a仍然是一个回文串，我们用d-i-j-来表示A-i…j-这个子串变成回文串所需要添加的最少的字符数，那么对于A-i-A-j-的情况，很明显有" class="headerlink" title="典型的区间模型，回文串拥有很明显的子结构特征，即当字符串s是一个回文串时，在X两边各添加一个字符’a’后，a s a仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i] == A[j]的情况，很明显有"></a>典型的区间模型，回文串拥有很明显的子结构特征，即当字符串s是一个回文串时，在X两边各添加一个字符’a’后，a s a仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i] == A[j]的情况，很明显有</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d[i][j] = d[i+1][j-1]</span><br></pre></td></tr></table></figure>
<h4 id="这里需要明确一点，当i-1-gt-j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d-i-1-j-1-0；"><a href="#这里需要明确一点，当i-1-gt-j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d-i-1-j-1-0；" class="headerlink" title="这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1] = 0；"></a>这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1] = 0；</h4><h4 id="当A-i-A-j-时，我们将它变成更小的子问题求解，我们有两种决策："><a href="#当A-i-A-j-时，我们将它变成更小的子问题求解，我们有两种决策：" class="headerlink" title="当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策："></a>当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策：</h4><h4 id="1-在A-j-后面添加一个字符A-i-；"><a href="#1-在A-j-后面添加一个字符A-i-；" class="headerlink" title="1.在A[j]后面添加一个字符A[i]；"></a>1.在A[j]后面添加一个字符A[i]；</h4><h4 id="2-在A-i-前面添加一个字符A-j-；"><a href="#2-在A-i-前面添加一个字符A-j-；" class="headerlink" title="2.在A[i]前面添加一个字符A[j]；"></a>2.在A[i]前面添加一个字符A[j]；</h4><h3 id="列出状态转移方程-3"><a href="#列出状态转移方程-3" class="headerlink" title="列出状态转移方程"></a>列出状态转移方程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d[i][j] = min&#123; d[i+1][j], d[i][j-1] &#125; + 1; </span><br><span class="line">//每次状态转移，区间长度增加1</span><br></pre></td></tr></table></figure>
<h5 id="注：此算法空间复杂度O-n-2-，时间复杂度O-n-2-。存在优化方法，此处不与给出。"><a href="#注：此算法空间复杂度O-n-2-，时间复杂度O-n-2-。存在优化方法，此处不与给出。" class="headerlink" title="注：此算法空间复杂度O(n^2)，时间复杂度O(n^2)。存在优化方法，此处不与给出。"></a>注：此算法空间复杂度O(n^2)，时间复杂度O(n^2)。存在优化方法，此处不与给出。</h5>]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划优化</title>
    <url>/2019/11/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-前缀-后缀优化"><a href="#1-前缀-后缀优化" class="headerlink" title="1.前缀/后缀优化"></a>1.前缀/后缀优化</h2><p>利用O(n)预处理前缀/后缀信息，使得后续调用区段信息时可以O(1)完成。</p><p>思想比较简单，也比较容易想到，但是往往因为不想浪费一个线型数组的空间而弃用，其实完全没必要担心这样的空间……</p><blockquote>
<p>前缀/后缀优化 练习列表</p>
</blockquote><blockquote>
<p><a href="https://www.luogu.org/problem/P2513" target="_blank" rel="noopener">LuoGu2513 [HAOI2009]逆序对数列</a></p>
</blockquote><blockquote>
<p><a href="https://www.luogu.org/problem/P4099" target="_blank" rel="noopener">LuoGu4099 [HEOI2013]SAO</a></p>
</blockquote><a id="more"></a>




<blockquote>
<p><a href="https://www.luogu.org/problem/P2511" target="_blank" rel="noopener">LuoGu2511 [HAOI2008]木棍分割</a></p>
</blockquote>
<blockquote>
<p><code>备注:</code>前缀和只是附带优化，与dp类型关系不大</p>
</blockquote>
<hr>
<h2 id="2-单调队列优化"><a href="#2-单调队列优化" class="headerlink" title="2.单调队列优化"></a>2.单调队列优化</h2><p>用单调队列维护最值，解决有序扫描的序列问题(滑动窗口)。</p>
<p>转移方程往往可以写作:</p>
<p>$$\large f_i=\frac{max}{min}\ ^{i-1}<em>{j=l_i}{g[j]}+w_i\ ,\ l_i\leq l</em>{i+1}$$</p>
<p>显然，如果我们在同一个区间内发现对于一个g(j)，存在更优的g(k)，由于区间有序右移，故j比k更早消失，对k出现后的所有答案无法做出任何贡献，故将j弹出单调队列。</p>
<p>单调队列的队首元素总是最优的，其出队条件有两种：</p>
<p>1.队首元素不在转移区间内，弹出。</p>
<p>2.新区间内找到了更优的元素，弹出比新值劣的所有元素。</p>
<blockquote>
<p>单调队列优化 练习列表</p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1776" target="_blank" rel="noopener">LuoGu1776 宝物筛选</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2254" target="_blank" rel="noopener">LuoGu2254 [NOI2005]瑰丽华尔兹</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2569" target="_blank" rel="noopener">LuoGu2569 [SCOI2010]股票交易</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3572" target="_blank" rel="noopener">LuoGu3572 [POI2014]PTA-Little Bird</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3594" target="_blank" rel="noopener">LuoGu3594 [POI2015]WIL-Wilcze doły</a></p>
</blockquote>
<blockquote>
<p><code>备注:</code>$T_1$是单调队列优化多重背包</p>
</blockquote>
<hr>
<h2 id="3-二分栈决策优化"><a href="#3-二分栈决策优化" class="headerlink" title="3.二分栈决策优化"></a>3.二分栈决策优化</h2><p>在下貌似不会呢，留待下一步学习。</p>
<blockquote>
<p>二分栈优化 练习列表</p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1973" target="_blank" rel="noopener">LuoGu1973 [NOI2011]Noi嘉年华</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3724" target="_blank" rel="noopener">LuoGu3724 [AH2017/HNOI2017]大佬</a></p>
</blockquote>
<blockquote>
<p><code>备注:</code>二分栈的题目难度往往是NOI+,省选内基本不考察</p>
</blockquote>
<hr>
<h2 id="4-分治优化"><a href="#4-分治优化" class="headerlink" title="4.分治优化"></a>4.分治优化</h2><p>在下貌似写不出什么东西，因为没怎么用过呢，稍后试试水再回来写吧。</p>
<blockquote>
<p>分治优化 练习列表</p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P5504" target="_blank" rel="noopener">LuoGu5504 [JSOI2011]柠檬</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3515" target="_blank" rel="noopener">LuoGu3515 [POI2011]Lightning Conductor</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1912" target="_blank" rel="noopener">LuoGu1912 [NOI2009]诗人小G</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/CF868F" target="_blank" rel="noopener">CF868F Yet Another Minimization Problem</a></p>
</blockquote>
<blockquote>
<p><code>备注:</code>分治优化的练习题比较劝退，对着递推式都要好好想一阵子……</p>
</blockquote>
<hr>
<h2 id="5-斜率优化"><a href="#5-斜率优化" class="headerlink" title="5.斜率优化"></a>5.斜率优化</h2><p>斜率优化在复赛中考察可能性应该高于上述各种。常常用于接手一些方程类似于单调队列优化，但是不可用其优化的dp题。</p>
<p>不能使用单调队列的原因，主要是因为附加值不再是仅与i,j中的一个相关的值，而往往是与两者都相关的值，比如说：</p>
<p>$$\large f_i=\frac{max}{min}\ ^{i-1}<em>{j=l_i}{g[j]}+sum_i*sum_j\ ,\ l_i\leq l</em>{i+1}$$</p>
<p>由于交叉项sum的出现，单调队列就无法保证弹出的正确性。</p>
<p>此时将式子再多写一个i,k的关系式，不妨令k优于j,我们就可以把两个等式Aj和Ak，利用k优于j的关系相减，使得所有式子中与i相关的量是个定值，如(min为例)：</p>
<p>$$\large f_i=g[j]+sum_i*sum_j ······[A_j]$$</p>
<p>$$\large f_i=g[k]+sum_i*sum_k ······[A_k]$$</p>
<p>$$g[k]+sum_i<em>sum_k\leq g[j]+sum_i</em>sum_j(A_j\leq A_k)$$</p>
<p>这样就在j,k间建立起了不等关系，这样的不等关系可以用同类项作差相除的方式转成类似斜率的表达式:</p>
<p>$$g[k]-g[j]\leq sum_i*(sum_j-sum_k)$$</p>
<p>$$\frac{g[k]-g[j]}{sum_j-sum_k}\leq sum_i$$</p>
<p>现在我们令前者作为斜率，对斜率维护一个上凸包，即保证其最优即可。</p>
<p>怎么维护？使用单调队列或者单调栈。前者在斜率递增时可用队首维护最优决策；后者在i递增时可使用当前直线斜率转移。（<del>口胡带师</del>）</p>
<blockquote>
<p>斜率优化 练习列表</p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P4360" target="_blank" rel="noopener">LuoGu4360 [CEOI2004]锯木厂选址</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2900" target="_blank" rel="noopener">LuoGu2900 [USACO08MAR]土地征用Land Acquisition</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3195" target="_blank" rel="noopener">LuoGu3195 [HNOI2008]玩具装箱TOY</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3628" target="_blank" rel="noopener">LuoGu3628 [APIO2010]特别行动队</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2305" target="_blank" rel="noopener">LuoGu2305 [NOI2014]购票</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1721" target="_blank" rel="noopener">LuoGu1721 [NOI2016]国王饮水记</a></p>
</blockquote>
<blockquote>
<p><code>备注1:</code>最近把这些题的式子都重新推一下找找感觉</p>
</blockquote>
<blockquote>
<p><code>备注2:</code>$T_2$双倍经验见SP15086</p>
</blockquote>
<hr>
<h2 id="6-矩阵优化递推"><a href="#6-矩阵优化递推" class="headerlink" title="6.矩阵优化递推"></a>6.矩阵优化递推</h2><p>主要用于多阶递推式的快速转移取模。</p>
<p>例如，对于</p>
<p>$$f[i]=f[i-1]+2*f[i-3]$$</p>
<p>我们连续推进，可以得到这样的数个式子：</p>
<p>$$f[n]=1<em>f[n-1]+0</em>f[n-2]+2*f[n-3]$$</p>
<p>$$f[n-1]=1<em>f[n-1]+0</em>f[n-2]+0*f[n-3]$$</p>
<p>$$f[n-2]=0<em>f[n-1]+1</em>f[n-2]+0*f[n-3]$$</p>
<p>把系数拆分出来，我们就得到了一个这样的矩阵：</p>
<p>$$A=\begin{bmatrix}1&amp;0&amp;2\1&amp;0&amp;0\0&amp;1&amp;0\end{bmatrix}$$</p>
<p>然后我们发现对于递推矩阵B，存在下列关系：</p>
<p>$$B_n=\begin{bmatrix}f_{n}\f_{n-1}\f_{n-2}\end{bmatrix}$$</p>
<p>$$B_{n-1}*A=B_n$$</p>
<p>$$B_1*A^{n-1}=B_n$$</p>
<p>所以我们发现可以利用矩阵快速幂的方式，对A矩阵进行n-1幂次求值，再使其与B1相乘就得到了结果。</p>
<p>方法简单，主要是别忘了怎么推式子。</p>
<blockquote>
<p>矩阵优化递推 练习列表</p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3758" target="_blank" rel="noopener">LuoGu3758 [TJOI2017]可乐</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P4910" target="_blank" rel="noopener">LuoGu4910 帕秋莉的手环</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P5004" target="_blank" rel="noopener">LuoGu5004 专心OI - 跳房子</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P4967" target="_blank" rel="noopener">LuoGu4967 黑暗打击</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.luogu.org/problem/P5558" target="_blank" rel="noopener">LuoGu5558 心上秋</a></p>
</blockquote>
<blockquote>
<p><code>备注:</code>已经按照难度排序。</p>
</blockquote>
<hr>
<h2 id="7-数据结构优化"><a href="#7-数据结构优化" class="headerlink" title="7.数据结构优化"></a>7.数据结构优化</h2><p>考差的不多，但是对于优化时间之类还是很有用。</p>
<p>内容较多，日后填坑。</p>
<hr>
<h2 id="8-滚维优化"><a href="#8-滚维优化" class="headerlink" title="8.滚维优化"></a>8.滚维优化</h2><p>上述内容好像都是时间优化，对于某些空间爆炸的题滚维也是很必要的。</p>
<p>要滚维需满足下列条件：</p>
<p>1.矩阵式递推相邻行之间可以转移，并且不再涉及到以前的状态，所以可以存两行，用完就扔。<code>滚掉行数</code></p>
<p>2.对于一些多维递推中以1递变的状态，可以滚掉。(其实包含1.)</p>
<p>3.……</p>
<hr>
<h2 id="9-一些奇怪的优化"><a href="#9-一些奇怪的优化" class="headerlink" title="9.一些奇怪的优化"></a>9.一些奇怪的优化</h2><p>杂项，往往是可遇而不可求，很多都是现想出来的，不遇到特定类型的题目几乎用不着（雾）。</p>
<ul>
<li>扫序列的时候在干什么？时间够不够？考虑下随机吗？</li>
</ul>
<p>话说随机对序列选数问题简直是一大杀伤性算法，因为往往这样的题目数据不会允许递推，搜索也需要极大的剪枝，那为什么不当一个快乐的人呢？</p>
<blockquote>
<p>小孩子才做选择，我<del>全都要</del>无所谓。</p>
</blockquote>
<ul>
<li>为什么排个序就不一样？</li>
</ul>
<p>很大一部分dp的题目需要先对数据进行排序，比如上述的<strong>土地征用</strong>，这样就能保证顺序递推的正确性。</p>
<ul>
<li>正着推还是倒着推？</li>
</ul>
<p>记得到的死记，记不到的<del>随缘</del>现推。</p>
<hr>
<h2 id="10-看看就好的优化"><a href="#10-看看就好的优化" class="headerlink" title="10.看看就好的优化"></a>10.看看就好的优化</h2><p>DP凸优化？</p>
<p>WQS二分优化？</p>
<p>带权二分优化？</p>
<p><img src="https://cn.bing.com/th?id=OIP.8YjJYd0vp0QMGB2JJ1k1cgHaEL&pid=Api&rs=1" alt></p>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增求最近公共祖先</title>
    <url>/2019/11/23/%E5%80%8D%E5%A2%9E%E6%B1%82lca/</url>
    <content><![CDATA[<blockquote>
<p>如何求最近公共祖先？</p>
</blockquote><blockquote>
<p>朴素的想法:$dfs_1$标记深度，深度大的先跳到与深度小的一级，再同时向上跳，直到找到$LCA$。</p>
</blockquote><p>怎么形容呢？一个字：<del>那是真的</del> <em>慢</em> <del>的要飞起</del></p><p>怎么办？考虑大步流星的跳：<strong>倍增</strong>。</p><p>倍增的过程，就是每次跳$2^?$深度，就能把效率提高到$\log$级。</p><p>怎么实现？<strong>类似动规思想</strong>，用$f[i][j]$来表示$i$的第$2^j$辈祖先。</p><a id="more"></a>





<blockquote>
<p>小小的特判：$f[i][0]$系$i$父结点，而不存在的节点记为$f[i][j]=0$。</p>
</blockquote>
<p>$Caution!$ 由于$2^{k-1}+ 2^{k-1}=2^k$</p>
<p>所以有递推式：</p>
<p> $f[i][j]=\begin{cases}f[f[i][j-1]][j-1]&amp;1\leqslant j\leqslant \log{n} \fa[i]&amp;j=0\end{cases}$ </p>
<p> 预处理复杂度O($nlogn$)；</p>
<p> 怎么查询？</p>
<ul>
<li><p>交换两个变量的值，保证前者深度大，便于操作。</p>
</li>
<li><p>拆分步数，试着走$2^{logn}$到$2^0$步，如果走完之后深的点还是深，则把此点更新到他上一步走到的那个祖先处</p>
</li>
<li><p>单方面调整后，如果二者到达同一深度已经满足找到$LCA$，那么结束，否则调整两个点同上试探性倍增，保持深度一致并$while$不相遇于$LCA$时继续。</p>
</li>
<li><p>$while$结束后，取出当下的父结点f[i][0]，即二者$LCA$。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20031125</span>;</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">int</span> nex;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">itn f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _ceil=<span class="number">19</span>;<span class="comment">//这就够了2^20=1048576</span></span><br><span class="line">	dep[u]=dep[fa]|<span class="number">1</span>;<span class="comment">//+1=|1</span></span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">0</span>;i&lt;=_ceil;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[u][i+<span class="number">1</span>]=f[f[u][i]][i];<span class="comment">//父子递推</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ri i=head[u];i;i=e[i].nex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(to==fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			f[to][<span class="number">0</span>]=u;<span class="comment">//定义父子关系</span></span><br><span class="line">			init(to,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y])</span><br><span class="line">	&#123;</span><br><span class="line">		swap(x,y);<span class="comment">//调整深度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[f[x][i]]&gt;dep[y])</span><br><span class="line">		&#123;</span><br><span class="line">			x=f[x][i];<span class="comment">//jmp</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//单方面倍增至同深度</span></span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[x][i]!=f[y][i])</span><br><span class="line">		&#123;</span><br><span class="line">			x=f[x][i];</span><br><span class="line">			y=f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//同时倍增</span></span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];<span class="comment">//找汇合点前的点的父亲即LCA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询复杂度O($logn$)</p>
<p>例题：<a href="https://www.luogu.org/problemnew/show/P3884" target="_blank" rel="noopener">LuoGu3884:二叉树问题</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lca求法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> nex;</span><br><span class="line">&#125; e[maxn*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],dep[maxn],f[maxn][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].v=v;</span><br><span class="line">	e[cnt].nex=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">	f[u][<span class="number">0</span>]=fa;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i)&lt;=dep[u]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=e[i].nex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].v;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa)</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y])</span><br><span class="line">	&#123;</span><br><span class="line">		swap(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[x]&lt;=dep[y]-(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">		&#123;</span><br><span class="line">			y=f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[x][i]==f[y][i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			x=f[x][i];</span><br><span class="line">			y=f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> right;</span><br><span class="line">	<span class="keyword">int</span> left;</span><br><span class="line">	<span class="keyword">int</span> fa;</span><br><span class="line">	<span class="keyword">int</span> dep;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125; t[<span class="number">25000</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,ans,sum[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	t[<span class="number">1</span>].dep=<span class="number">1</span>;</span><br><span class="line">	t[<span class="number">1</span>].fa=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		add(x,y);</span><br><span class="line">		add(y,x);</span><br><span class="line">		<span class="keyword">if</span>(t[x].left==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			t[x].left=y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			t[x].right=y;</span><br><span class="line">		&#125;</span><br><span class="line">		t[y].fa=x;</span><br><span class="line">		t[y].dep=t[x].dep+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(t[y].dep&gt;ans)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=t[y].dep;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[t[i].dep]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">int</span> res=lca(a,b);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(t[a].dep-t[res].dep)*<span class="number">2</span>+t[b].dep-t[res].dep;<span class="comment">//距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ADD:<a href="https://www.luogu.org/blog/firstfan/LCA-solve-RMQ" target="_blank" rel="noopener">$RMQ$问题的$LCA$解决</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Size Balanced Tree</title>
    <url>/2019/11/23/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5DSize%20Balanced%20Tree/</url>
    <content><![CDATA[<p>$\sf\large\text{Size Balanced Tree}$(节点大小平衡树，下简称SBT)是陈启峰在WC2007提出的一种新型平衡树。</p><p>SBT的高度为log n，其核心操作maintain()复杂度O(1)，其他操作均为O(log n)，所以是平衡树中非常优秀的一种。其主要通过子树大小来维持其平衡性质。</p><a id="more"></a>

<p>和其他平衡树一样，SBT支持大部分较为常规的操作：</p>
<ul>
<li>“以x为根的子树”在下文中简称为”x子树”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">insert(x,val):向x子树插入值为val的结点</span><br><span class="line">del(x,val):删除x子树中值为val的结点</span><br><span class="line">find(x,val):查找x子树中值为val的结点</span><br><span class="line">rank(x,val):返回x子树中val的排名</span><br><span class="line">kth(x,k):返回x子树中排名第k的结点(大小排序均可)</span><br><span class="line">pre(x,val):返回x子树中val的前驱</span><br><span class="line">suc(x,val):返回x子树中val的后继</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{1.SBT的结点定义}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].r</span></span><br><span class="line"><span class="comment">//下文中的ls,rs均为此处宏定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l;<span class="comment">//左子树</span></span><br><span class="line">	<span class="keyword">int</span> r;<span class="comment">//右子树</span></span><br><span class="line">	<span class="keyword">int</span> val;<span class="comment">//值</span></span><br><span class="line">	<span class="keyword">int</span> siz;<span class="comment">//子树大小</span></span><br><span class="line">&#125;t[maxn];</span><br></pre></td></tr></table></figure>

<p>SBT有一个特殊的性质需要维护:某子树的大小大于等于其兄弟子树的大小。</p>
<p>直观写出来就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[ls(i)].siz&gt;=max(t[rs(rs(x))].siz,t[ls(rs(x))].siz);</span><br><span class="line">t[rs(i)].siz&gt;=max(t[ls(ls(x))].siz,t[rs(ls(x))].siz);</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{2.SBT的左右旋}$</p>
<p>SBT也是需要旋转的，且同样分为左右旋两种。</p>
<p><img src="https://i.loli.net/2019/10/20/MU1AmnYzRbjoV6c.png" alt></p>
<p>我们列出旋转前后的状态，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">左旋前:</span><br><span class="line">根:rt	左子树的根:L</span><br><span class="line">右子树的根:R_rt	右子树的子树:R_l,R_r</span><br><span class="line">左旋后:</span><br><span class="line">根:R_rt	右子树的根:R_r</span><br><span class="line">左子树的根:rt	左子树的子树:L,R_l</span><br><span class="line"></span><br><span class="line">右旋前:</span><br><span class="line">根:rt	右子树的根:R</span><br><span class="line">左子树的根:L_rt	右子树的子树:L_l,L_r</span><br><span class="line">右旋后:</span><br><span class="line">根:L_rt	左子树的根:L_l</span><br><span class="line">右子树的根:rt	右子树的子树:L_r,R</span><br></pre></td></tr></table></figure>

<p>左右旋代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrot</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y=rs(x);</span><br><span class="line">	rs(x)=ls(y);</span><br><span class="line">	ls(y)=x;</span><br><span class="line">	t[y].siz=t[x].siz;</span><br><span class="line">	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+<span class="number">1</span>;</span><br><span class="line">	x=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rrot</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y=ls(x);</span><br><span class="line">	ls(x)=rs(y);</span><br><span class="line">	rs(y)=x;</span><br><span class="line">	t[y].siz=t[x].siz;</span><br><span class="line">	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+<span class="number">1</span>;</span><br><span class="line">	x=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{3.SBT的维护}$</p>
<p>首先，假设一株满足条件的SBT长这样：</p>
<p><img src="https://i.loli.net/2019/10/20/khYEgfinPvxerM3.png" alt></p>
<p>此时有A.siz,B.siz≤R.siz并且C.siz,D.siz≤L.siz</p>
<p>每当插入一个值的时候，平衡树的平衡性就可能被打破，所以我们要使用O(1)的<code>maintain(x)</code>对x子树进行修复操作。</p>
<p>插入后，可能会出现以下的四种情况:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* t[ls(ls(x))].siz&gt;t[rs(x)].siz</span><br><span class="line">* t[ls(rs(x))].siz&gt;t[rs(x)].siz</span><br><span class="line">* t[rs(rs(x))].siz&gt;t[ls(x)].siz</span><br><span class="line">* t[rs(ls(x))].siz&gt;t[ls(x)].siz</span><br></pre></td></tr></table></figure>

<p>直接分类处理会很复杂。但SBT的对称性质使我们只用讨论两种情况：</p>
<p>$\sf 1.t[ls(ls(x))].siz&gt;t[rs(x)].siz$</p>
<p>看到上图，对于T子树，此时的情况就是A.siz&gt;R.siz，显然此时就导致平衡性质受损。</p>
<p>第一步，我们先将其右旋，得到下面这株可能仍然不满足性质的树：</p>
<p><img src="https://i.loli.net/2019/10/20/AGUZCcN69DI2kjo.png" alt></p>
<p>之所以说可能仍不满足性质，是因为C.siz&gt;B.siz或D.siz&gt;B.siz的情况可能发生，所以有必要再次使用maintain(T)。这样一来，L的右子树就会被多次调整，不过别担心，每次调整都是O(1)的。</p>
<p>$\sf 1.t[rs(ls(x))].siz&gt;t[rs(x)].siz$</p>
<p>（为了直观，此处增加结点数）上述情况在下图中表示为：B.siz&gt;R.siz</p>
<p><img src="https://i.loli.net/2019/10/20/8VOo7kwPWxZFQCT.png" alt></p>
<p>那么对称地，我们先进行左旋，得到：</p>
<p><img src="https://i.loli.net/2019/10/20/TMjQJtFUi1aRBXl.png" alt></p>
<p>不同的是，接下来我们还要进行一次右旋，得到:</p>
<p><img src="https://i.loli.net/2019/10/20/rsWMngUahG2qvZw.png" alt></p>
<p>有同学可能就会问了：左旋右旋过后这棵树就很不稳定了，怎么办？</p>
<p>答：没事，至少图中的小子树还是满足性质的，所以只要maintain一下L和T就可以让L,T子树平衡。最后再来一次maintain(B)即可。</p>
<p>情况3,4与上述两种情况分别相反，对应操作即可，此处不再赘述。</p>
<p>maintain采用递归实现，具有一定的对称美感。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">bool</span> lr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lr)<span class="comment">//左边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[ls(ls(x))].siz&gt;t[rs(x)].siz)<span class="comment">//#1</span></span><br><span class="line">		&#123;</span><br><span class="line">			rrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[rs(ls(x))].siz&gt;t[rs(x)].siz)<span class="comment">//#2</span></span><br><span class="line">		&#123;</span><br><span class="line">			lrot(ls(x));</span><br><span class="line">			rrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//右边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[rs(rs(x))].siz&gt;t[ls(x)].siz)<span class="comment">//#3</span></span><br><span class="line">		&#123;</span><br><span class="line">			lrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[ls(rs(x))].siz&gt;t[ls(x)].siz)<span class="comment">//#4</span></span><br><span class="line">		&#123;</span><br><span class="line">			rrot(rs(x));</span><br><span class="line">			lrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	maintain(ls(x),<span class="number">1</span>);</span><br><span class="line">	maintain(rs(x),<span class="number">0</span>);</span><br><span class="line">	maintain(x,<span class="number">0</span>);</span><br><span class="line">	maintain(x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{4.插入元素}$</p>
<p>SBT的插入和其他平衡树基本一致,只是向非空子树插入元素时要maintain一下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=++cnt;</span><br><span class="line">		ls(x)=rs(x)=<span class="number">0</span>;</span><br><span class="line">		t[x].siz=<span class="number">1</span>;</span><br><span class="line">		t[x].val=val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		t[x].siz++;</span><br><span class="line">		<span class="keyword">if</span>(val&lt;t[x].val)</span><br><span class="line">		&#123;</span><br><span class="line">			insert(ls(x),val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			insert(rs(x),val);</span><br><span class="line">		&#125;</span><br><span class="line">		maintain(x,val&lt;t[x].val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{5.查找前驱&amp;后继}$</p>
<p>查找前驱函数pre()，我们传入三个参数：</p>
<ul>
<li>x:当前子树</li>
<li>p:保存的前驱结点</li>
<li>val:查找值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[x].val&gt;=val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pre(ls(x),p,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pre(rs(x),x,val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后继同理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[x].val&gt;val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> suc(ls(x),x,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> suc(rs(x),p,val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{6.删除元素}$</p>
<p>删除元素的操作与BST的删除基本一致。删除之后maintain也是没有必要的，其原因是：</p>
<blockquote>
<p>虽然不能保证删完后还是SBT，但是树的最大深度不会变化，时间复杂度也并不变化，maintain就显得多余了。</p>
</blockquote>
<p>删除有两种主流方法，均可使用：</p>
<p>1.后继替换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[x].siz--;</span><br><span class="line">	<span class="keyword">if</span>(val&gt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		del(rs(x),val);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		del(ls(x),val);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(ls(x)&amp;&amp;!rs(x))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> reg=x;</span><br><span class="line">		x=ls(x);</span><br><span class="line">		<span class="keyword">return</span> reg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!ls(x)&amp;&amp;rs(x))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> reg=x;</span><br><span class="line">		x=rs(x);</span><br><span class="line">		<span class="keyword">return</span> reg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!ls(x)&amp;&amp;!rs(x))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> reg=x;</span><br><span class="line">		x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> reg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> reg=rs(x);</span><br><span class="line">		<span class="keyword">while</span>(ls(res))</span><br><span class="line">		&#123;</span><br><span class="line">			reg=ls(reg);</span><br><span class="line">		&#125;</span><br><span class="line">		t[x].val=t[reg].val;</span><br><span class="line">		del(rs(x),t[reg].val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//reg是临时暂存变量</span></span><br></pre></td></tr></table></figure>

<p>2.前驱替换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> reg;</span><br><span class="line">	t[x].size--;</span><br><span class="line">	<span class="keyword">if</span>((val==t[x].val)||(val&lt;t[x].val&amp;&amp;!ls(x))||(val&gt;t[x].val&amp;&amp;!rs(x)))</span><br><span class="line">	&#123;</span><br><span class="line">		reg=t[x].val;</span><br><span class="line">		<span class="keyword">if</span>(ls(x)&amp;&amp;rs(x))</span><br><span class="line">		&#123;</span><br><span class="line">			t[x].val=del(ls(x),t[x].val+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			x=ls(x)+rs(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(val&gt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		reg=del(rs(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		reg=del(ls(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\sf\large\text{7.一系列的查询操作}$</p>
<p>1.最值查询(单向爬树)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extremum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> minmax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(minmax)<span class="comment">//最小值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(ls(x))</span><br><span class="line">		&#123;</span><br><span class="line">			x=ls(x);</span><br><span class="line">		&#125;<span class="comment">//一直向左爬</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//最大值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(rs(x))</span><br><span class="line">		&#123;</span><br><span class="line">			x=rs(x);</span><br><span class="line">		&#125;<span class="comment">//一直向右爬</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t[x].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.查询第k小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cur=t[ls(x)].siz+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(cur==k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> t[x].val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(cur&gt;k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> kth(ls(x),k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> kth(rs(x),k-cur);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要查询第k大，则对几个选择结构中的内容进行交换并调整即可。</p>
<p>3.查找排名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val==t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> t[ls(x)].siz+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> rank(ls(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		rank(rs(x),val)+t[ls(x)].siz+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于树高log n的证明以及maintain时间复杂度O(1)的证明，陈启峰在论文中有提到，详见<a href="https://www.luogu.org/blog/firstfan/SBT-prove" target="_blank" rel="noopener">此处</a>。</p>
<p>最后，以<a href="https://www.luogu.org/problem/P3369" target="_blank" rel="noopener">LuoGu3369</a>作为例题，<a href="https://www.luogu.org/paste/1iktxkt4" target="_blank" rel="noopener">SBT的代码实现见此</a>，用时142ms，已经算是很优秀的平衡树了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2019/11/23/segment%20tree/</url>
    <content><![CDATA[<blockquote>
<p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为 $O(\log N)$ 。而未优化的空间复杂度为 $2N$ ，因此有时需要离散化让空间压缩。</p>
</blockquote><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>在 $\sf\ O(\log N)$ 的时间复杂度内实现：</p><a id="more"></a>

<p>单点修改、区间修改、区间查询$\sf\ etc.$</p>
<p>线段树维护的信息需要满足<code>可加性</code>，如果使用标记，标记也要满足可加性。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p><strong>基本结构与建树</strong></p>
<p>有个数组 $\sf\ a={10,11,12,13,14}$ 要进行区间求和操作</p>
<p>怎么把这个数组存到线段树中呢？</p>
<ul>
<li><p>设线段树的根节点编号为 $1$ </p>
</li>
<li><p>用数组 $d$ 来保存我们的线段树</p>
</li>
<li><p>$d[i]$ 用来保存编号为 $i$ 的节点的值（这里节点的值就是这个节点所表示的区间总和）<br>如图所示：</p>
</li>
</ul>
<p><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1g24xita4czg31280lk7wo.gif" alt></p>
<p>设$\sf\ d[i]$是线段树中的结点。</p>
<ul>
<li><p>$\sf\ d[i]$ 的左节点是 $\sf\ d[ls(i)]$</p>
</li>
<li><p>$\sf\ d[i]$ 的右节点是 $\sf\ d[rs(i)]$</p>
</li>
</ul>
<blockquote>
<p>如果 $\sf\ d[i]$ 表示的是区间 $\sf\ [l,r]$</p>
</blockquote>
<blockquote>
<p>$\sf\ d[i]$ 的左儿子节点表示的是区间 $\sf\ [l, \frac{l+r}{2} ]$ </p>
</blockquote>
<blockquote>
<p>$\sf\ d[i]$ 的右儿子表示的是区间 $\sf\ [ \frac{l+r}{2} +1,r]$ 。</p>
</blockquote>
<p><strong>如何实现？</strong></p>
<p>如图</p>
<p><img src="https://s2.ax1x.com/2019/11/16/Mwkdat.gif" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> leaf (l==r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(leaf)</span><br><span class="line">	&#123;</span><br><span class="line">		d[p]=a[s];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(l,mid,ls(p));</span><br><span class="line">	build(mid+<span class="number">1</span>,r,rs(p));</span><br><span class="line">	d[p]=d[ls(p)]+d[rs(p)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于线段树的空间: </p>
<p>如果采用$\sf\ 2p$ 是 $\sf\ p$ 的左儿子，$\sf\ 2p+1$ 是 $\sf\ p$ 的右儿子的存储方式(<code>堆存储</code>)，则$\sf\  d $数组的长度应为$\sf\ 2^{\left\lceil\log{n}\right\rceil+1}$，亦即取 $2$ 的幂中第一个大于等于 $\sf\ n$ 的幂并将其乘二作为$\sf\ d$数组的长度。</p>
<p>一般来说，开四倍是怎么样都够了的，但是在卡空间的题里要进行类似于动态开点的操作。</p>
<p><strong>区间查询</strong></p>
<p>区间查询，比如求区间 $\sf\ [l,r]$ 的和的操作。</p>
<p><img src="https://s2.ax1x.com/2019/11/16/MwA7ff.gif" alt></p>
<p>比如查询区间$\sf\ [3,5]$，把 $\sf\ [3,5]$ 拆成 $\sf\ [3,3]$ 和 $\sf\ [4,5]$ 就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> l_now,<span class="keyword">int</span> r_now,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//[l,r]为查询区间,[l_now,r_now]为当前节点包含的区间,p为当前节点的编号</span></span><br><span class="line">	<span class="keyword">if</span>(l&lt;=l_now&amp;&amp;r_now&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> d[p];<span class="comment">//当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l_now+r_now)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=getsum(l,r,l_now,mid,ls(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果左儿子代表的区间[l,m]与询问区间有交集,则递归查询左儿子</span></span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=getsum(l,r,mid+<span class="number">1</span>,r_now,rs(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果右儿子代表的区间[m+1,r]与询问区间有交集,则递归查询右儿子</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要思路是把区间拆成左右区间，再分别处理。(分治)</p>
<p><strong>区间修改&amp;懒标记</strong></p>
<p>修改区间$\sf\ [l , r]$需要进行<strong>打懒标记</strong>的操作来减少时间消耗。</p>
<p>设一个数组 $\sf\ laz$ ， $\sf\ laz[i]$ 表示编号为 $\sf\ i$ 的节点的<strong>懒标记</strong>。</p>
<p><strong>区间修改（区间加）:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interval_add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val,<span class="keyword">int</span> l_now,<span class="keyword">int</span> r_now,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//[l,r]为修改区间,val为被修改的元素的变化量,[l_now,r_now]为当前节点包含的区间,p为当前节点的编号</span></span><br><span class="line">	<span class="keyword">if</span>(l&lt;=l_now&amp;&amp;r_now&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		d[p]+=(r_now-l_now+<span class="number">1</span>)*val;</span><br><span class="line">		laz[p]+=val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="comment">//当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span></span><br><span class="line">	<span class="keyword">int</span> mid=(l_now+r_now)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(laz[p]&amp;&amp;!leaf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">		d[ls(p)]+=laz[p]*(mid-l_now+<span class="number">1</span>);</span><br><span class="line">		d[rs(p)]+=laz[p]*(r_now-mid);</span><br><span class="line">		</span><br><span class="line">		laz[ls(p)]+=laz[p];</span><br><span class="line">		laz[rs(p)]+=laz[p];<span class="comment">//将标记下传给子节点</span></span><br><span class="line">		laz[p]=<span class="number">0</span>;<span class="comment">//清空当前节点的标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		interval_add(l,r,val,l_now,mid,ls(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		interval_add(l,r,val,mid+<span class="number">1</span>,r_now,rs(p));</span><br><span class="line">	&#125;</span><br><span class="line">	d[p]=d[ls(p)]+d[rs(p)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区间查询（求和）:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> l_now,<span class="keyword">int</span> r_now,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//[l,r]为查询区间,[l_now,r_now]为当前节点包含的区间,p为当前节点的编号</span></span><br><span class="line">	<span class="keyword">if</span>(l&lt;=l_now&amp;&amp;r_now&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> d[p];<span class="comment">//当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l_now+r_now)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=getsum(l,r,l_now,mid,ls(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果左儿子代表的区间[l,m]与询问区间有交集,则递归查询左儿子</span></span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=getsum(l,r,mid+<span class="number">1</span>,r_now,rs(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果右儿子代表的区间[m+1,r]与询问区间有交集,则递归查询右儿子</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现区间赋值，把所有 <code>+=</code> 替换成 <code>=</code> 即可</p>
<p>(除$sum+=getsum(l,r,mid+1,r,rs(p)$ )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interval_value</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val,<span class="keyword">int</span> l_now,<span class="keyword">int</span> r_now,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=l_now&amp;&amp;r_now&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		d[p]=(r_now-l_now+<span class="number">1</span>)*val;</span><br><span class="line">		laz[p]=val;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l_now+r_now)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(laz[p])</span><br><span class="line">	&#123;</span><br><span class="line">		d[ls(p)]=laz[p]*(mid-l_now+<span class="number">1</span>);</span><br><span class="line">		d[rs(p)]=laz[p]*(r_now-mid);</span><br><span class="line">		laz[ls(p)]=laz[rs(p)]=laz[p];</span><br><span class="line">		laz[p]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		interval_value(l,r,val,l_now,mid,ls(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		interval_value(l,r,val,mid+<span class="number">1</span>,r_now,rs(p));</span><br><span class="line">	&#125;</span><br><span class="line">	d[p]=d[ls(p)]+d[rs(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> l_now,<span class="keyword">int</span> r_now,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=l_now&amp;&amp;r_now&lt;=r)<span class="keyword">return</span> d[p];</span><br><span class="line">	<span class="keyword">int</span> mid=(l_now+r_now)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(laz[p])</span><br><span class="line">	&#123;</span><br><span class="line">		d[ls(p)]=laz[p]*(mid-l_now+<span class="number">1</span>);</span><br><span class="line">		d[rs(p)]=laz[p]*(r_now-mid);</span><br><span class="line">		laz[ls(p)]=laz[rs(p)]=laz[p];</span><br><span class="line">		laz[p]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=getsum(l,r,l_now,mid,ls(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=getsum(l,r,mid+<span class="number">1</span>,r_now,rs(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<ul>
<li><p>位运算优化</p>
</li>
<li><p>递归到叶节点的时候叶节点一定包含在查询区间内，所以一定会在懒惰标记下放前就处理完$\sf\ return $，所以叶节点懒标记下放不会导致数组越界，也不用每次检查是否为叶节点了。</p>
</li>
<li><p>如果懒标记不会超出数据范围，那么可以将标记永久化，永久化可以避免下传标记，降低程序常数。</p>
</li>
</ul>
<p>小练1.<a href="https://www.luogu.org/problem/show?pid=3372" target="_blank" rel="noopener">LuoGu3372:线段树1</a></p>
<p>小练2.<a href="https://www.luogu.org/problem/show?pid=3372" target="_blank" rel="noopener">LuoGu3373:线段树2</a></p>
<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>SBT的时间/空间复杂度证明</title>
    <url>/2019/11/23/SBT%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-对于SBT树高log-n的证明"><a href="#1-对于SBT树高log-n的证明" class="headerlink" title="1.对于SBT树高log n的证明"></a>1.对于SBT树高log n的证明</h2><p>设 f[x] 是高度为 x 的结点个数最少的 SBT 的结点个数。</p><p>f[x]有一个结论如下：</p><p>$\sf f[x]=\begin{cases}1,(x=0)\2,(x=1)\f[x-1]+f[x-2]+1,(x&gt;1)\end{cases}$</p><p>显然，f[0]=1,f[1]=2;</p><a id="more"></a>



<p>f[x]=f[x-1]+f[x-2]+1(x&gt;1)的证明：</p>
<p>对于每个x，设 t 指向一个高度为 x 的 SBT ，然后这个 SBT 包含一个高度为 x-1 的子树。不妨设它就是左子树。</p>
<p>通过前面对于 f[x] 的定义，我们得到t[ls(x)].siz&gt;=f[x-1]，并且在左子树上有一棵高为 x-2 的子树，或者说有一棵大小（ siz ）至少为 f[x-1] 的子树在左子树上。由性质可得t[ls(x)].siz&gt;=f[x-2]。</p>
<p>故而有f[x]=f[x-1]+f[x-2]+1(x&gt;1)。</p>
<p>也可以通过构造特殊SBT进行证明：</p>
<p><img src="https://i.loli.net/2019/10/20/Ho8dzTJycwKmRgb.png" alt></p>
<p>对于递推函数f,我们发现它具有斐波那契数列的相似性质，则利用特征根方程可以求出通项公式：</p>
<p>$\sf\Large f[x]=\frac{u^{x+3}-v^{x+3}}{\sqrt5}-1=||\frac{u^{x+3}}{\sqrt 5}-1||$</p>
<p>其中u=$\frac{1+\sqrt{5}}{2}$,v=$\frac{1-\sqrt{5}}{2}$。</p>
<p>下面是一张计算表，可以看见f[x]较小的值</p>
<p><img src="https://i.loli.net/2019/10/20/GWqVDzCvlu4PQeH.png" alt></p>
<p>那么接下来对于最差高度maxh进行证明(引自论文):</p>
<p><img src="https://i.loli.net/2019/10/20/HF6A1WXr8p5lRym.png" alt></p>
<p>可得最差树高是log n级别的。</p>
<h2 id="2-对于SBT-maintain-时间复杂度O-1-的证明"><a href="#2-对于SBT-maintain-时间复杂度O-1-的证明" class="headerlink" title="2.对于SBT maintain()时间复杂度O(1)的证明"></a>2.对于SBT maintain()时间复杂度O(1)的证明</h2><p>通过前面的结论，我们可以很容易的证明 Maintain 过程是非常有效的 过程 。</p>
<p>评价一棵 BST 时有一个非常重要的值，那就是 <code>结点的平均深度</code>。它是通过所有结点深度和除以总结点个数 n 获得的。通常它会很小，而 BST 会更小 。</p>
<p>因为对于每个常数 n ，我们都期望结点深度和 （缩写为 SD ） 尽可能的小。</p>
<p>现在我们的目的是<code>削减结点深度和</code>，而它就是用来约束 Maintain 的次数。</p>
<p>回顾一下 Maintain 中执行旋转的条件，会发现结点深度和在旋转后<code>总是在减小</code>。</p>
<p>感性分析后，再进行理性证明(引自论文):</p>
<p><img src="https://i.loli.net/2019/10/20/ta2mDnfZ68Gwp4z.png" alt></p>
<p>可见maintain()函数均摊只有O(1)，非常快速。</p>
<h2 id="3-SBT综合性能分析"><a href="#3-SBT综合性能分析" class="headerlink" title="3.SBT综合性能分析"></a>3.SBT综合性能分析</h2><p>一张图说明效率：</p>
<p><img src="https://i.loli.net/2019/10/20/A79QNE61RvJC3Zr.png" alt></p>
<p>两张表对比速度：</p>
<p><img src="https://i.loli.net/2019/10/20/oPSfdFGhs5gtlwC.png" alt></p>
<p>这说明SBT在时间复杂度上胜于一般的平衡树。</p>
<p>另外，不像一般平衡树，SBT只用维护一个额外的siz值即可，而siz值往往又是题目中要求的，所以可以视作不存储额外信息。而treap等则需要另外存储随机权值，颜色等等，空间上SBT也略胜一筹。</p>
<h3 id="总结而言……SBT天下第一！"><a href="#总结而言……SBT天下第一！" class="headerlink" title="总结而言……SBT天下第一！"></a>总结而言……SBT天下第一！</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>nexT主题下插件的引入</title>
    <url>/2019/11/23/nexT%E4%B8%BB%E9%A2%98%E4%B8%8B%E5%BC%95%E5%85%A5%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>nexT是一个自由度较高的hexo主题，我们可以对其引入一些插件来优化网页阅读体验。(<del>这哪里在重要啊喂？</del>)此处将详细描述如何引入我博客中的插件。</p><h2 id="鼠标点击の烟花效果"><a href="#鼠标点击の烟花效果" class="headerlink" title="鼠标点击の烟花效果"></a>鼠标点击の烟花效果</h2><p><img src="https://i.loli.net/2019/11/17/8QeDbVRgfjCuTKo.png" alt></p><p>之前我有在<a href="https://www.mina.moe/" target="_blank" rel="noopener">mina.moe</a>这个博客网页上写过博，对这个烟花点击效果很喜欢，就专门找了出来。</p><p>设置方法如下：</p><p>1.进入<code>themes/next/source/js</code>新建文件夹<code>src</code></p><a id="more"></a>




<p><img src="https://i.loli.net/2019/11/17/HaSO5gytiDx6o8r.png" alt></p>
<p>2.在<code>/src</code>新建fireworks.js，内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>有点长，但文意还算清晰，可以进行个性化修改。</p>
<p>3.打开<code>themes/next/layout/_layout.swig</code>，在<code>&lt;/body&gt;</code>前一点点（其实就是在<code>&lt;body&gt;&lt;/body&gt;</code>中间）插入语句：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">if</span> <span class="string">theme.fireworks</span> <span class="string">%&#125;</span></span><br><span class="line">   <span class="string">&lt;canvas</span> <span class="string">class="fireworks"</span> <span class="string">style="position:</span> <span class="string">fixed;left:</span> <span class="number">0</span><span class="string">;top:</span> <span class="number">0</span><span class="string">;z-index:</span> <span class="number">1</span><span class="string">;</span> <span class="attr">pointer-events:</span> <span class="string">none;"</span> <span class="string">&gt;&lt;/canvas&gt;</span> </span><br><span class="line">   <span class="string">&lt;script</span> <span class="string">type="text/javascript"</span> <span class="string">src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt;</span> </span><br><span class="line">   <span class="string">&lt;script</span> <span class="string">type="text/javascript"</span> <span class="string">src="/js/src/fireworks.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">endif</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/17/NiyadZc1zRw34tj.png" alt></p>
<p>4.打开<code>themes/next/_config.yml</code>，这是主题配置文件，在文末加上语句:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fireworks</span></span><br><span class="line"><span class="attr">fireworks:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>5.如果需要加载别的点击效果，请将<code>true</code>更改为<code>false</code>即可。</p>
<h2 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h2><p>我的博客内可以看见有两个“看板娘”：</p>
<p><img src="https://i.loli.net/2019/11/17/GRJBdvoFlPfLhIn.png" alt></p>
<p>这就是接下来我要介绍的两种引入看板娘插件的方式</p>
<h3 id="从stevenjoezhang的live2d-widget项目中直接调用"><a href="#从stevenjoezhang的live2d-widget项目中直接调用" class="headerlink" title="从stevenjoezhang的live2d-widget项目中直接调用"></a>从<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">stevenjoezhang的live2d-widget项目</a>中直接调用</h3><p>1.插件需要jQuery和font-awesome支持。打开<code>themes/next/layout/_layout.swig</code>，在<code>&lt;head&gt;</code>栏加入:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，如果你此前加载过了就不必再加了。</p>
<p>2.在<code>&lt;head&gt;</code>栏中加入:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.提交以后就可见效果了，人物列表在项目中有列出，此处的33即此类live2d。</p>
<p><img src="https://i.loli.net/2019/11/17/JMUFmg9l5QTAyXS.png" alt></p>
<h3 id="利用nodejs安装hexo-helper-live2d包"><a href="#利用nodejs安装hexo-helper-live2d包" class="headerlink" title="利用nodejs安装hexo-helper-live2d包"></a>利用<code>nodejs</code>安装<code>hexo-helper-live2d</code>包</h3><p>1.运行cmd.exe并cd到博客目录下，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>

<p>即可安装live2d插件，安装较慢请耐心等待。如果要卸载则可使用”uninstall”</p>
<p>2.在<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a>选择想要放进网页的人物并记住其名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名字列表</span><br><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure>

<p>3.利用<code>npm</code>在博客目录下安装相应的人物包，<code>cmd.exe</code>中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-？ 【？需要替换为表格中的人物】</span><br></pre></td></tr></table></figure>

<p>4.在<strong>博客</strong>的配置文件<code>_config.yml</code>文末加入:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-？</span> <span class="comment">#同理，这也要换</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span> <span class="comment">#这是人物的位置</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>5.提交上传后就会出现人物啦~</p>
<p><img src="https://i.loli.net/2019/11/17/wrkUsIjuRJbQZqc.png" alt></p>
<h2 id="网易云音乐播放器"><a href="#网易云音乐播放器" class="headerlink" title="网易云音乐播放器"></a>网易云音乐播放器</h2><p>网易云音乐本身提供音乐播放器的外链，方便了我们将歌曲播放器嵌入到博客中。</p>
<p><img src="https://i.loli.net/2019/11/17/GD3HkC4FdhWys2f.png" alt></p>
<p>1.首先在网易云上搜索你想放的歌曲，进入播放页面，点击<code>生成外链播放器</code></p>
<p><img src="https://i.loli.net/2019/11/17/9FhnsHIWR7l485y.png" alt></p>
<p>此时有可能提示版权问题，如有此问题请更换曲目<del>或者采用技术手段</del></p>
<p>2.复制其中的<code>html</code>代码</p>
<p><img src="https://i.loli.net/2019/11/17/3kyMzKZCW9s6xDY.png" alt></p>
<p>3.打开<code>layout/_macro/sidebar.swig</code>并加入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    在这里放上你的html代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.可以通过更改html代码中<code>auto</code>的值设置其是否自动播放：1自动播放，0不自动播放，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=730859&amp;auto=1&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.保存上传后就可以看见播放器啦~</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>七濑胡桃❤</title>
    <url>/2019/11/23/menhera/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/07/18/5d300b9dd384516079.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e1029594052.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e28cf948090.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e5bd2357156.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e5bdba71125.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e5bc8946438.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e651f128326.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9e64c5372019.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9ed7cab30584.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300b9ed7cbb44446.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d140521b97727.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d141287480779.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d141ebd870653.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d142960a52393.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d1431e1f62600.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d143c3f327268.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d14434de77533.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d144e88543683.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d145687177804.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d14652d057801.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d31b3b0e32820.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d31be25083669.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d31c856041244.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d31d306b39874.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d31de13475839.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d31e8b2966180.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d3209b6171597.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d3219f8368532.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d3222ac227846.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d322d23895238.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d49a88be84777.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d49bfdde62065.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d49c875810894.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d49f1bcc82335.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d4a0ae3286953.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d4a2314a82394.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d4a3b69d85354.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d4a43c6b33981.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d4a5155925978.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d4a595d644326.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d63166b888873.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d632ba4377256.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d633f13b62360.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d63503d753961.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d635920a54719.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d6363d8c23482.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d636a2e814082.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d6373fef98640.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d638141c79263.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d6393bee22784.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d89da65180618.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d89e351446433.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d89e9d3847589.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a01f0653998.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a0a73f23477.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a11d3a52153.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a1e8a544492.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a2e32837131.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a35cd236843.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300d8a468cc30920.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e305122359670.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e3083f6b46251.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e30b8b4f98166.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e31252bd55886.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e315711396714.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e3168b2a49508.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e3178bf397698.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e318ca2921881.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e31988d623390.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e31a6b7857835.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e527cf0a85087.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e529000c11291.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52a118b22909.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52ad47625719.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52b9e2412065.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52c741377110.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52d2fc329787.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52e67ee72121.png" alt><br><img src="https://i.loli.net/2019/07/18/5d300e52f2a2063161.png" alt></p><h1 id="text-我永远喜欢"><a href="#text-我永远喜欢" class="headerlink" title="$\text{我永远喜欢}$"></a>$\text{我永远喜欢}$</h1><h1 id="mathcal-menhera-chan"><a href="#mathcal-menhera-chan" class="headerlink" title="$\mathcal menhera\ chan!$"></a>$\mathcal menhera\ chan!$</h1>]]></content>
      <categories>
        <category>Girls</category>
      </categories>
      <tags>
        <tag>杂</tag>
        <tag>Girls</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-LuoGu5021</title>
    <url>/2019/11/23/LG5021/</url>
    <content><![CDATA[<p>$\tiny\text{似乎巨佬都没有翻译题目，其实部分难度在于题目翻译，所以:}$</p><h2 id="先翻译下本题的题意："><a href="#先翻译下本题的题意：" class="headerlink" title="先翻译下本题的题意："></a>先翻译下本题的题意：</h2><ul>
<li>$n$个点，$n-1$条边，任意两点可以互相到达，每条道路仅从属于一条“赛道”。</li>
</ul><p>眼熟？$\color{blue}\text{其实就是一棵树。}$</p><ul>
<li>要建$m$条“赛道”，赛道无环，<strong>最大化</strong>最短道路。</li>
</ul><a id="more"></a>



<p>对了！$\color{red}\text{就是二分答案！}$</p>
<p>那么整道题翻译出来就很简洁了：</p>
<ul>
<li>给出有$n$个节点的一棵树的信息，从中选出$m$条链，满足链之间互不相交，并最大化最短链长。</li>
</ul>
<hr>
<p>进入二分前，先想想二分什么，二分所需要的上界在哪。</p>
<ul>
<li><p>二分什么？明显：二分最小链长。</p>
</li>
<li><p>二分上界？明显：树的直径。<a href="https://firstfan.blog.luogu.org/post-xue-xi-ji-lu-dong-tai-gui-hua" target="_blank" rel="noopener">(树的直径的概念)</a></p>
</li>
</ul>
<p>那么我们可以树形$DP$一次求出树的直径。</p>
<p>比如我们拿$Sample\ 2$来讲：($len$是边长）</p>
<p><img src="https://i.loli.net/2019/04/09/5cacb4ae5237f.png" alt></p>
<p>那么我们可以看到，这棵树被切成了$3$条无交集的链，其中最短链是$1-&gt;2-&gt;7$，它的长度是$15$，此时最大化。</p>
<p>这棵树的直径是$7-&gt;2-&gt;3-&gt;4-&gt;5$长度为$27$，那么二分最短边的长度就好了。</p>
<ul>
<li>$Check()$怎么写？</li>
</ul>
<p>回到这幅图，我们可以看到对于每条链，我们可以找到其上一个点（以下简称<strong>特征点</strong>），使得此<strong>链</strong>与该点的<strong>上方树</strong>无交集。即是说，该链为<strong>特征点子树的子集</strong>。</p>
<p>那么对于上图，特征点分别为（按颜色）：$\color{red}\text{1}$,$\color{lime}\text{2}$,$\color{darkblue}\text{4}$</p>
<p>下面是<del>废话</del>时间：</p>
<p>如果一个链，它经过了结点$i$的<strong>父结点</strong>，同时包含了$i$<strong>到子结点的某条边</strong>，那么它只能包含$i$到所有子结点的边<strong>当中的一条</strong>。</p>
<p>这句<del>废话</del>推广一下的话就很有用了：</p>
<p>对于任意节点$i$及其子节点$j,k$以及其中的一条链$i-&gt;j$，有$3$种情况需要讨论：(设$i$的父结点为$f_i$)</p>
<ul>
<li><p>弃置</p>
</li>
<li><p>使用为$j-&gt;i-&gt;k$的链<code>（儿子找父亲说另外一个儿子惹祸）</code></p>
</li>
<li><p>使用为$f_i-&gt;i-&gt;j$的链</p>
</li>
</ul>
<p>那么分类就很简单了：</p>
<p>对于每个结点$i$进行连边的尝试（连一个或两个）:</p>
<p>如果连一个的话就<strong>把新边长向上传递并与父结点合并入同一链</strong>（<code>连两个的话说明它就是特征点</code>）</p>
<p>似乎思路走远了？不是要二分吗？</p>
<p>再看看？我们有一个二分链长$len$，就可以按照上面的步骤连了，如果连出来的链长大于$len$就计数重开一条新链，如果统计下来链数不够，我们就缩小$len$二分，反之类比。</p>
<p>似乎忘了什么？我们不仅要保证链的数量最多，还要保证最短的链最大化！那么我们每次传回父结点的边长一定要尽量长。</p>
<p>所以我们就有加链条件：</p>
<p>$len_pre+len_now&gt;=binary_len$</p>
<p>这里采用$multiset$进行维护。</p>
<p><del>复杂度？不好说</del></p>
<p>下面是代码，有简洁的注释，又不懂的欢迎在评论区提问，即时$Update!$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flg=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=getchar();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        flg=<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                c=getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">        &#123;</span><br><span class="line">                num=(num&lt;&lt;<span class="number">1</span>)+(num&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">                c=getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num*flg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20031125</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">int</span> nex;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> edge_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++edge_cnt].to=v;</span><br><span class="line">	e[edge_cnt].nex=head[u];</span><br><span class="line">	e[edge_cnt].val=val;</span><br><span class="line">	head[u]=edge_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dia,dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diameter</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(ri i=head[u];i;i=e[i].nex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to=e[i].to;</span><br><span class="line">		<span class="keyword">int</span> val=e[i].val;</span><br><span class="line">		<span class="keyword">if</span> (vis[to])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		diameter(to);</span><br><span class="line">		dia=max(dia,dp[u]+dp[to]+val);</span><br><span class="line">		dp[u]=max(dp[u],dp[to]+val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//树形dp求直径</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt,edge;</span><br><span class="line">	node(<span class="keyword">int</span> cnt_,<span class="keyword">int</span> edge_)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=cnt_;</span><br><span class="line">		edge=edge_;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flg;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> binary_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>,edge=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; _set;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ri i=head[x];i;i=e[i].nex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to=e[i].to;</span><br><span class="line">		<span class="keyword">int</span> val=e[i].val;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (to == fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node son=dfs(to,x,binary_len);</span><br><span class="line">		<span class="keyword">if</span> (val+son.edge &gt;= binary_len)</span><br><span class="line">		&#123;</span><br><span class="line">			++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_set.insert(val+son.edge);</span><br><span class="line">		&#125;</span><br><span class="line">		cnt += son.cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (!_set.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it=_set.upper_bound(<span class="number">0</span>);<span class="comment">//迭代器</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> top=*it;<span class="comment">//迭代器的值</span></span><br><span class="line">		_set.erase(it);</span><br><span class="line">		it=_set.lower_bound(binary_len-top);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (it == _set.end())</span><br><span class="line">		&#123;</span><br><span class="line">			edge=top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_set.erase(it);</span><br><span class="line">			++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cnt &gt;= m)</span><br><span class="line">	&#123;</span><br><span class="line">		flg=<span class="literal">true</span>;<span class="comment">//个数过多</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node(cnt,edge);<span class="comment">//推进去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((time)(<span class="number">0</span>));</span><br><span class="line">	n=read();</span><br><span class="line">	m=read();</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=read();</span><br><span class="line">		<span class="keyword">int</span> v=read();</span><br><span class="line">		<span class="keyword">int</span> val=read();</span><br><span class="line">		add(u,v,val);</span><br><span class="line">		add(v,u,val);</span><br><span class="line">	&#125;</span><br><span class="line">	diameter(<span class="number">1</span>);<span class="comment">//直径</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r=dia;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span> (l&lt;=r)<span class="comment">//二分最短长</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		flg=<span class="literal">false</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">0</span>,mid);<span class="comment">//flg赋值</span></span><br><span class="line">		<span class="keyword">if</span> (flg)</span><br><span class="line">		&#123;</span><br><span class="line">			l=mid+rand()%<span class="number">2</span>;</span><br><span class="line">			ans=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			r=mid-rand()%<span class="number">2</span>;<span class="comment">//原谅我至今不知道是否要加减。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>&amp;<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 1</span></span><br><span class="line"><span class="comment">1 2 10</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">2 4 9</span></span><br><span class="line"><span class="comment">2 5 8</span></span><br><span class="line"><span class="comment">3 6 6</span></span><br><span class="line"><span class="comment">3 7 7</span></span><br><span class="line"><span class="comment">out:</span></span><br><span class="line"><span class="comment">31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>反思与小结：（前面浪费时间系列）</p>
<p>其实根本不需要求直径，无脑取一个大值就好了（所有边长之和就不错），求直径的时间可以用来多二分几次，并且此题时间卡得并不很紧，否则必须要用平衡树维护链长和特征点了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-LuoGu3496</title>
    <url>/2019/11/23/LG3496/</url>
    <content><![CDATA[<blockquote>
<h3 id="这是一个非黑即白的世界。"><a href="#这是一个非黑即白的世界。" class="headerlink" title="这是一个非黑即白的世界。"></a>这是一个非黑即白的世界。</h3></blockquote><p>想必各位都看过题目了，首先翻译下题意：</p><blockquote>
<h3 id="给一幅无向图，你可以对其每个点染色，要求白黑必须挨着，灰色必须和黑白挨着，问能否染色以及染色方案。"><a href="#给一幅无向图，你可以对其每个点染色，要求白黑必须挨着，灰色必须和黑白挨着，问能否染色以及染色方案。" class="headerlink" title="给一幅无向图，你可以对其每个点染色，要求白黑必须挨着，灰色必须和黑白挨着，问能否染色以及染色方案。"></a>给一幅无向图，你可以对其每个点染色，要求白黑必须挨着，灰色必须和黑白挨着，问能否染色以及染色方案。</h3></blockquote><p>我们可以考虑到，灰色点必然可以被黑白交替的模式代替，所以我们只要黑白染色就好，灰色可以请出去了。怎么染色？要把每个点都要染到？还要交替染？</p><a id="more"></a>



<p>我们立即想到一个点的入度越少越好，因为这样一个点对于其周围点的影响最小。入度最小？如果图连通，我们可以把它降为1——$\color{red}\sf\large\text{生成树}$恰好满足这一性质。</p>
<p><code>图不连通呢？</code>题上可是说了，如果不能成功染色，那么输出<code>NIE</code>退出就好，另外我们可以想到，联通的图一定是可以完成染色的，所以可以大胆输出<code>TAK</code></p>
<p>那么！我们再回头看一眼题目，就是这样的：</p>
<blockquote>
<h3 id="给一幅无向图，找出里面的生成树，对其上的每个点黑白交替染色，问图是否连通，若连通则输出每个点的颜色-有SPJ"><a href="#给一幅无向图，找出里面的生成树，对其上的每个点黑白交替染色，问图是否连通，若连通则输出每个点的颜色-有SPJ" class="headerlink" title="给一幅无向图，找出里面的生成树，对其上的每个点黑白交替染色，问图是否连通，若连通则输出每个点的颜色(有SPJ)"></a>给一幅无向图，找出里面的生成树，对其上的每个点黑白交替染色，问图是否连通，若连通则输出每个点的颜色(有SPJ)</h3></blockquote>
<p>是否很明了了？献上一份代码（附简注），此处我用的是常规存图+dfs染色。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这个图中的生成树上染色就好，白黑交替染</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flg=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flg=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		num=(num&lt;&lt;<span class="number">1</span>)+(num&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num*flg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">int</span> nex;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].to=v;</span><br><span class="line">	e[cnt].nex=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> col[maxn];</span><br><span class="line"><span class="comment">//非黑即白</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//这个vis[]要用两次：</span></span><br><span class="line"><span class="comment">//第一次：用来排查图中是否存在孤立点</span></span><br><span class="line"><span class="comment">//第二次：用来记录该点是否上色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nd,<span class="keyword">bool</span> cur)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当前的点，当前的颜色(黑/白)</span></span></span><br><span class="line"><span class="function"><span class="comment">//灰色太尖酸了，不必参加染色。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[nd]=<span class="literal">true</span>;</span><br><span class="line">	col[nd]=cur;</span><br><span class="line">	<span class="keyword">for</span>(ri i=head[nd]; i; i=e[i].nex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!vis[to])</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(to,!cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=read();</span><br><span class="line">	<span class="keyword">int</span> m=read();</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=read();</span><br><span class="line">		<span class="keyword">int</span> v=read();</span><br><span class="line">		vis[u]=vis[v]=<span class="literal">true</span>;<span class="comment">//不是孤立点</span></span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//显然，有一个点孤立，不可能全部连上。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>&amp;(<span class="keyword">int</span>)<span class="built_in">printf</span>(<span class="string">"NIE"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//能到这里，就说明一定可以连通.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"TAK"</span>);</span><br><span class="line">	fill(vis+<span class="number">1</span>,vis+n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//清空，准备记录是否上色</span></span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(i,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(col[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"K"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"S"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下：这道题我们首先排除掉了<code>不可能存在的情况</code>，或者说存在了亦可以被代替的情况（因为<code>SPJ</code>）；随后我们找到了<code>树上染色</code>是最优的情况，解决问题。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>动态规划</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-LG3099</title>
    <url>/2019/11/23/LG3099/</url>
    <content><![CDATA[<p>本题题意简单：给出两组大小为n的点集，问点集A中任取三点形成的三角形围住点集B中点的数量，以及B包A的数量。</p><p>其实题目可以进一步简化：我们来看一幅图（样例解释）</p><p><img src="https://i.loli.net/2019/09/15/k9uW1PR8hpZ5IfQ.png" alt></p><p>我们可以主观感受一下，红点被蓝点包了一个，蓝点被红点包了俩。</p><p>回想一下，我们是怎么判断的呢？一个个三角形枚举吗？$\sf\color{red}\text{并不是！}$</p><a id="more"></a>




<p>多感受几次，我们发现：如果一个点被异色点围成的一个多边形围住，那么它就被捕了（如下图）。<strong>但是为什么？</strong></p>
<p><img src="https://i.loli.net/2019/09/15/DBA3CNYsJqWprxh.png" alt></p>
<p>别忘了，当你把所有可能的三角形围出来的时候，就注定把这些点围成的多边形覆盖，因为所有的三角形边中一定包含了这个多边形的边。还是以图举例。</p>
<p><img src="https://i.loli.net/2019/09/15/Jx8SYV6XMGznfgp.png" alt></p>
<p>显然这个五个点围出了五边形（为了美观，有部分三角形未画出）</p>
<p>直入主题，这样的多边形我们称之为$\sf\color{red}\text{凸包}$。那么我们现在需要的就是<code>判断点是否在凸包内</code>了。</p>
<p>关于凸包，网上已有详细的讲解，此处不作赘述。</p>
<p>那么此题中，我们采用的是常规的二分判断叉积法判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取其中的一个点，他和其他点可以组成n-2个三角形，利用二分判断差积，</span></span><br><span class="line"><span class="comment">//判断他是在当前三角形内，还是在三角形左边，还是在三角形右边，或者是三角形外。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(dot b,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r=n<span class="number">-2</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		ll cr1=(bor[mid]-bor[<span class="number">0</span>])*(b-bor[<span class="number">0</span>]);</span><br><span class="line">		ll cr2=(bor[mid+<span class="number">1</span>]-bor[<span class="number">0</span>])*(b-bor[<span class="number">0</span>]);<span class="comment">//叉积</span></span><br><span class="line">		<span class="keyword">if</span>(cr1&gt;=<span class="number">0</span>&amp;&amp;cr2&lt;=<span class="number">0</span>)<span class="comment">//也就是说此时该点b在bor[mid]上方或其线上，又在bor[mid+1]下方或其线上</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((bor[mid+<span class="number">1</span>]-bor[mid])*(b-bor[mid])&gt;<span class="number">0</span>) <span class="comment">//bor[mid]-&gt;bor[mid+1] 与 bor[mid]-&gt;b 的叉积</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="comment">//如果此时叉积大于等于0,说明该点b在该三角形内部或者边界上</span></span><br><span class="line">			<span class="comment">//经过卡数据，此题边界点不计入内。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//点在三角形外部</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cr1&lt;<span class="number">0</span>)  <span class="comment">//如果该点在bor[mid]下方，那么把上边界缩小到mid-1</span></span><br><span class="line">		&#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//如果该点在bor[mid+1]上方，那么把下边界拉至mid+1</span></span><br><span class="line">		&#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么有了判断法，我们就先求出AB两点集的凸包，并且用对集的点一个个代入判断即可，这是思维量最小的方式。</p>
<ul>
<li>不得不提的一点：此题的边界不算入内，有一个点恰好点在凸包边界上，不能计入内。</li>
</ul>
<p><strong>为不影响阅读，<a href="https://www.luogu.org/blog/firstfan/code-p3099" target="_blank" rel="noopener">完整代码请移步此处</a></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>数学</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-LG1486</title>
    <url>/2019/11/23/LG1486/</url>
    <content><![CDATA[<p>利用最近学的数据结构SBT过了此题，故来讲讲节点大小平衡树的做法。[<a href="https://www.luogu.org/blog/firstfan/size-balanced-tree" target="_blank" rel="noopener">戳我了解Size-Balanced-Tree</a>]</p><p>这道题考察了大部分平衡树的操作，如插入、删除、查第k大元素等，所以可以视为弱化版的模板。</p><p>此题特别的一点就是要用一个变量统计一下所有成员的工资，一个比较妙的操作是：在员工加入后直接存储他与最低工资的差值即可</p><a id="more"></a>


<p>简析一下四种操作怎么处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>插入权值为k-min的结点</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>把SBT上所有结点的值加k</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>把SBT上所有结点的值减k，减完后把低于min的结点删除。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查询SBT第k大，可以转化为SBT第(siz-k)小。如果范围越树尺寸输出<span class="number">-1</span>就好。</span><br></pre></td></tr></table></figure>

<p>最后，请注意一个<strong>坑点</strong>：在加入新成员的时候，要注意如果他一来就不符合条件，就直接<del>劝退</del>不insert即可。</p>
<p>此处未对SBT进行封装，简洁明了，便于理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flg=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flg=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		num=(num&lt;&lt;<span class="number">1</span>)+(num&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num*flg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (t[x].l)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (t[x].r)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">&#125; t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrot</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y=rs(x);</span><br><span class="line">	rs(x)=ls(y);</span><br><span class="line">	ls(y)=x;</span><br><span class="line">	t[y].siz=t[x].siz;</span><br><span class="line">	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+<span class="number">1</span>;</span><br><span class="line">	x=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rrot</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y=ls(x);</span><br><span class="line">	ls(x)=rs(y);</span><br><span class="line">	rs(y)=x;</span><br><span class="line">	t[y].siz=t[x].siz;</span><br><span class="line">	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+<span class="number">1</span>;</span><br><span class="line">	x=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">bool</span> lr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!lr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[ls(ls(x))].siz&gt;t[rs(x)].siz)</span><br><span class="line">		&#123;</span><br><span class="line">			rrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[rs(ls(x))].siz&gt;t[rs(x)].siz)</span><br><span class="line">		&#123;</span><br><span class="line">			lrot(ls(x));</span><br><span class="line">			rrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[rs(rs(x))].siz&gt;t[ls(x)].siz)</span><br><span class="line">		&#123;</span><br><span class="line">			lrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[ls(rs(x))].siz&gt;t[ls(x)].siz)</span><br><span class="line">		&#123;</span><br><span class="line">			rrot(rs(x));</span><br><span class="line">			lrot(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	maintain(ls(x),<span class="number">0</span>);</span><br><span class="line">	maintain(rs(x),<span class="number">1</span>);</span><br><span class="line">	maintain(x,<span class="number">1</span>);</span><br><span class="line">	maintain(x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)</span><br><span class="line">	&#123;</span><br><span class="line">		x=++cnt;</span><br><span class="line">		t[x].val=val;</span><br><span class="line">		t[x].siz=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	t[x].siz++;</span><br><span class="line">	<span class="keyword">if</span>(val&lt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		insert(ls(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		insert(rs(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	maintain(x,val&gt;=t[x].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[x].siz--;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(val==t[x].val||(val&lt;t[x].val&amp;&amp;!ls(x))||(val&gt;t[x].val&amp;&amp;!rs(x)))</span><br><span class="line">	&#123;</span><br><span class="line">		res=t[x].val;</span><br><span class="line">		<span class="keyword">if</span>(!ls(x)||!rs(x))</span><br><span class="line">		&#123;</span><br><span class="line">			x=ls(x)+rs(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			t[x].val=del(ls(x),t[x].val+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(val&lt;t[x].val)</span><br><span class="line">	&#123;</span><br><span class="line">		res=del(ls(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		res=del(rs(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val==t[ls(x)].siz+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> t[x].val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;=t[ls(x)].siz)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> kth(ls(x),val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> kth(rs(x),val-t[ls(x)].siz<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=read();</span><br><span class="line">	<span class="keyword">int</span> lim=read();</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line">	rt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tt=<span class="number">0</span>;</span><br><span class="line">	t[<span class="number">0</span>].siz=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="keyword">int</span> k=read();</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'I'</span>&amp;&amp;k&gt;=lim)</span><br><span class="line">		&#123;</span><br><span class="line">			insert(rt,k-add);</span><br><span class="line">			++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			add+=k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'S'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j;</span><br><span class="line">			add-=k;</span><br><span class="line">			<span class="keyword">while</span>(tot&amp;&amp;(j=kth(rt,<span class="number">1</span>))+add&lt;lim)</span><br><span class="line">			&#123;</span><br><span class="line">				del(rt,j);</span><br><span class="line">				--tot;</span><br><span class="line">				++ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'F'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(k&gt;tot)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(rt,tot-k+<span class="number">1</span>)+add);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA巧解RMQ问题</title>
    <url>/2019/11/23/lca&amp;rmq/</url>
    <content><![CDATA[<p>最近在学$LCA$算法的时候发现了很有意思的一个方法：</p><p><strong>建树，利用$LCA$解决$RMQ$问题。</strong></p><p>现在就来讲讲$RMQ$问题的$LCA$解决。</p><p>先来个例子：</p><p>已知序列A={2,8,5,7,1,4}，求区间[l,r]之间的最小值。</p><ul>
<li>第一步：建立树$T$</li>
</ul><p>我们把全局最小值$1$作为根节点，建立一棵<strong>优先级树</strong>。</p><p><img src="https://i.loli.net/2019/03/24/5c96f7d470280.png" alt></p><p>接下来，我们<strong>建立右子树</strong>，但$1$右侧只有一个结点可建：$4$</p><a id="more"></a>








<p><img src="https://i.loli.net/2019/03/24/5c96f977d920b.png" alt></p>
<p>下一步建立<strong>左子树</strong>，左子树有$4$个结点可建：$2,8,5,7$</p>
<p>我们选择<strong>最小</strong>的$2$作为子树根结点建树</p>
<p><img src="https://i.loli.net/2019/03/24/5c96fbad2123f.png" alt></p>
<p>下面递归建树即可：</p>
<p><img src="https://i.loli.net/2019/03/24/5c96fd87ba3bc.png" alt></p>
<ul>
<li>第二步：$LCA$</li>
</ul>
<p>现在我们已经把序列$A$转换为了一棵优先级树，那么现在我们可以发现：$RMQ$问题已经转化为了求$LCA$。</p>
<p>比如：求 序列中值为$7$和$4$的元素之间的区间的最小值。</p>
<p>找一次$LCA$：$7,4$拥有最近公共祖先$1$，那么RMQ就是$1!!$</p>
<p><strong>回顾一下解决过程：</strong></p>
<ul>
<li>考察一个长度为$N$的序列$A$，按照如下方法将其递归建立为一棵树：</li>
<li>设序列中最小值为$A_k$，建立优先级为$A_k$的根节点$T_k$；</li>
<li>将$A_{1…k-1}$递归建树作为$T_k$的左子树；</li>
<li>将$A_{k+1…N}$递归建树作为$T_k$的右子树；</li>
<li>这棵树是一棵优先级树</li>
</ul>
<p>那么……</p>
<p>对于$RMQ$($A,i,j$)：<br>设序列中最小值为$Ak$，若$k∈$[$i, j$]，那么答案为$k$；</p>
<p>若$k &gt; j$，那么答案为$RMQ$($A_{1..k-1},i,j$)；</p>
<p>若$k &lt; i$，那么答案为$RMQ$($A_{k+1..N},i,j$)；</p>
<p>不难发现$RMQ$($A,i,j$) $=$ $LCA$($T,i,j$)！</p>
<ul>
<li>这就证明了$RMQ$问题可以转化为$LCA$问题。</li>
</ul>
<hr>
<p>那么继续思考：<strong>$LCA$问题可不可以转化为$RMQ$?</strong></p>
<p><code>答案是肯定的。</code></p>
<p>如果对<strong>有根树</strong>$T$进行$DFS$，将遍历到的结点按照$DFS$序记下，我们将得到一个<strong>长度为$2N-1$的序列</strong>，称之为$T$的<strong>欧拉序列$F$</strong></p>
<p><code>每个结点都在欧拉序列中出现</code>，记录结点$u$在欧拉序列中<strong>第一次出现的位置</strong>为$pos_u$</p>
<p>就比如说这样（版权所有:$first_fan$）</p>
<p><img src="https://s31.aconvert.com/convert/p3r68-cdx67/qkp6a-1guzn.gif" alt></p>
<p>那么我们就可以得到欧拉序列$F$，深度序列$B$，以及首次出现位置$pos_u$</p>
<p><img src="https://i.loli.net/2019/03/24/5c9715971f1fa.png" alt></p>
<p><strong>那么怎么转化为$RMQ?$</strong></p>
<ul>
<li><p>根据$DFS$的性质，对于两结点$u,v$，从$pos_u$遍历到$pos_v$的过程中经过$LCA(u, v)$<strong>有且仅有一次</strong>，且深度是深度序列$B[pos_u…pos_v]$中最小的</p>
</li>
<li><p>即$LCA(T, u, v)=RMQ(B, pos_u, pos_v)$【$O(N)$】</p>
</li>
</ul>
<h2 id="那么有-LCA-amp-RMQ-可以-O-N-内互相转化"><a href="#那么有-LCA-amp-RMQ-可以-O-N-内互相转化" class="headerlink" title="那么有$LCA$&amp;$RMQ$可以$O(N)$内互相转化"></a>那么有$LCA$&amp;$RMQ$可以$O(N)$内互相转化</h2><p>得到：一般$RMQ$问题可以$ST$表解决，并且在$O(n)$可以与利用$Tarjan$算法的$LCA$问题<strong>互相转化</strong>。</p>
<p>例题：<a href="https://www.luogu.org/problemnew/show/P4172" target="_blank" rel="noopener">($WC_{2006}$)LuoGu4172:水管局长</a></p>
<p>题目的模型翻译过来就是：</p>
<ul>
<li><p>定义一个路径的关键边为其边权最大的边；</p>
</li>
<li><p>定义一个路径的权值为其关键边权值；</p>
</li>
<li><p>定义两点之间最短路为所有路径中权值最小的一条；</p>
</li>
<li><p>两种操作：拆除无向边&amp;询问最短路</p>
</li>
</ul>
<p>这个问题的解决，我们需要引入<strong>最小生成森林</strong>以及$Kruskal$<strong>生成顺序森林</strong>的算法，详情请参考:</p>
<p><del>即将完成</del>的<a href="https://www.luogu.org/blog/firstfan/the-grand-poem-of-graph" target="_blank" rel="noopener">图论史诗板块</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS解数独</title>
    <url>/2019/11/23/DFS%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="Step-1-通过judge判断是否合法"><a href="#Step-1-通过judge判断是否合法" class="headerlink" title="Step.1 通过judge判断是否合法"></a>Step.1 通过judge判断是否合法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> row = now / <span class="number">9</span>;</span><br><span class="line">	<span class="comment">//当前行</span></span><br><span class="line">	<span class="keyword">int</span> col = now % <span class="number">9</span>;</span><br><span class="line">	<span class="comment">//当前列</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maap[row][j] == maap[row][col] &amp;&amp; j != col)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//这是检查同一行中的重复</span></span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maap[j][col] == maap[row][col] &amp;&amp; j != row)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//这是检查同一列中的重复</span></span><br><span class="line">	<span class="keyword">int</span> tmp_row = row / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp_col = col / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span>(j = tmp_row; j &lt; tmp_row + <span class="number">3</span>;++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = tmp_col; k &lt; tmp_row + <span class="number">3</span>; ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maap[j][k] == maap[row][col] &amp;&amp; j != row &amp;&amp; k != col)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//这是检查同一3*3小格中的重复</span></span><br><span class="line">	<span class="comment">//经过三个判断如果可以放那么则返回真</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>
<h2 id="Step-2-利用flowback回溯"><a href="#Step-2-利用flowback回溯" class="headerlink" title="Step.2 利用flowback回溯"></a>Step.2 利用flowback回溯</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flowback</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now == <span class="number">81</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		print_map();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">int</span> row = now / <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> col = now % <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span>(!vis[row][col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[row][col]=<span class="literal">true</span>;</span><br><span class="line">			maap[row][col] = i;<span class="comment">//赋值</span></span><br><span class="line">			<span class="keyword">if</span>(judge(now))</span><br><span class="line">			&#123;<span class="comment">//可以放</span></span><br><span class="line">				flowback(now+<span class="number">1</span>);<span class="comment">//进入下一层</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[row][col]=<span class="literal">false</span>;<span class="comment">//回溯</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		flowback(now+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Step-3-轻松愉快的输出print-map"><a href="#Step-3-轻松愉快的输出print-map" class="headerlink" title="Step.3 轻松愉快的输出print_map"></a>Step.3 轻松愉快的输出print_map</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;maap[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其实就是很简单的回溯，判重也超级简单，只是有可能跑得比较慢鹅已……"><a href="#其实就是很简单的回溯，判重也超级简单，只是有可能跑得比较慢鹅已……" class="headerlink" title="其实就是很简单的回溯，判重也超级简单，只是有可能跑得比较慢鹅已……"></a>其实就是很简单的回溯，判重也超级简单，只是有可能跑得比较慢鹅已……</h1><h1 id="最后还是良心的上个全代码，也请巨佬们在时间复杂度优化上加以指导！"><a href="#最后还是良心的上个全代码，也请巨佬们在时间复杂度优化上加以指导！" class="headerlink" title="最后还是良心的上个全代码，也请巨佬们在时间复杂度优化上加以指导！"></a>最后还是良心的上个全代码，也请巨佬们在时间复杂度优化上加以指导！</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> maap[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> row = now / <span class="number">9</span>;</span><br><span class="line">	<span class="comment">//当前行</span></span><br><span class="line">	<span class="keyword">int</span> col = now % <span class="number">9</span>;</span><br><span class="line">	<span class="comment">//当前列</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="comment">//同一行</span></span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maap[row][j] == maap[row][col] &amp;&amp; j != col)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同一列</span></span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maap[j][col] == maap[row][col] &amp;&amp; j != row)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同一小格</span></span><br><span class="line">	<span class="keyword">int</span> tmp_row = row / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp_col = col / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span>(j = tmp_row; j &lt; tmp_row + <span class="number">3</span>;++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = tmp_col; k &lt; tmp_row + <span class="number">3</span>; ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maap[j][k] == maap[row][col] &amp;&amp; j != row &amp;&amp; k != col)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//经过三个判断如果可以放那么则真的可以了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;maap[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flowback</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now == <span class="number">81</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		print_map();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> row = now / <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> col = now % <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span>(!vis[row][col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[row][col]=<span class="literal">true</span>;</span><br><span class="line">			maap[row][col] = i;<span class="comment">//赋值</span></span><br><span class="line">			<span class="keyword">if</span>(judge(now))</span><br><span class="line">			&#123;<span class="comment">//可以放</span></span><br><span class="line">				flowback(now+<span class="number">1</span>);<span class="comment">//进入下一层</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[row][col]=<span class="literal">false</span>;<span class="comment">//回溯</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		flowback(now+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;maap[i][j];</span><br><span class="line">			<span class="keyword">if</span>(maap[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i][j]=<span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//有数的地方就不自己放了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	flowback(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//从第0个数开始回溯</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> maap[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> flg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flg=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flg=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		num=(num&lt;&lt;<span class="number">1</span>)+(num&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num*flg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>,++num);</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(ri j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,maap[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maap[i][y]==k||maap[x][i]==k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x1=x/<span class="number">3</span>*<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> y1=y/<span class="number">3</span>*<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span>(ri i=x1;i&lt;x1+<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(ri j=y1;j&lt;y1+<span class="number">3</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(maap[i][j]==k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">9</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		print_map();</span><br><span class="line">		flg=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(maap[x][y]!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y==<span class="number">8</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(x+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			dfs(x,y+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">		    <span class="keyword">if</span>(judge(x,y,i)!=<span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		    	maap[x][y]=i;</span><br><span class="line">		    	<span class="keyword">if</span>(y==<span class="number">8</span>)</span><br><span class="line">		    	&#123;</span><br><span class="line">		    		dfs(x+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dfs(x,y+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(flg==<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">				maap[x][y]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=read();</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(maap,<span class="number">0</span>,<span class="keyword">sizeof</span>(maap));</span><br><span class="line">		<span class="keyword">for</span>(ri i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(ri j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%1d"</span>,&amp;maap[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		flg=<span class="number">0</span>;<span class="comment">//判断是否继续dfs</span></span><br><span class="line">		dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">000000000</span></span><br><span class="line"><span class="comment">817965430</span></span><br><span class="line"><span class="comment">652743190</span></span><br><span class="line"><span class="comment">175439820</span></span><br><span class="line"><span class="comment">308102950</span></span><br><span class="line"><span class="comment">294856370</span></span><br><span class="line"><span class="comment">581697240</span></span><br><span class="line"><span class="comment">903504610</span></span><br><span class="line"><span class="comment">746321580</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">781654392</span></span><br><span class="line"><span class="comment">962837154</span></span><br><span class="line"><span class="comment">543219786</span></span><br><span class="line"><span class="comment">439182675</span></span><br><span class="line"><span class="comment">158976423</span></span><br><span class="line"><span class="comment">627543918</span></span><br><span class="line"><span class="comment">316728549</span></span><br><span class="line"><span class="comment">895461237</span></span><br><span class="line"><span class="comment">274395861</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="撒花✿✿ヽ-°▽°-ノ✿"><a href="#撒花✿✿ヽ-°▽°-ノ✿" class="headerlink" title="撒花✿✿ヽ(°▽°)ノ✿"></a>撒花✿✿ヽ(°▽°)ノ✿</h1>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title>第一届CSP开幕在即！</title>
    <url>/2019/11/23/CSP2019!/</url>
    <content><![CDATA[<h1 id="CSP-S将在2019-11-16举行，2d-3-5h-d-共七个小时的算法设计。"><a href="#CSP-S将在2019-11-16举行，2d-3-5h-d-共七个小时的算法设计。" class="headerlink" title="CSP-S将在2019.11.16举行，2d*3.5h/d.共七个小时的算法设计。"></a>CSP-S将在2019.11.16举行，2d*3.5h/d.共七个小时的算法设计。</h1><h1 id="在此，退役选手first-fan祝各位CSP2019-RP-！"><a href="#在此，退役选手first-fan祝各位CSP2019-RP-！" class="headerlink" title="在此，退役选手first_fan祝各位CSP2019 RP++！"></a>在此，退役选手first_fan祝各位CSP2019 RP++！</h1><p><img src="https://i.loli.net/2019/11/15/A4oC8NLuvfbR327.png" alt></p>]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-CF888E</title>
    <url>/2019/11/23/CF888E/</url>
    <content><![CDATA[<p>咳咳…这道题的正解是meet-in-middle折半搜索</p><h3 id="但是！！我要讲讲大家喜闻乐见的玄学算法：随机化"><a href="#但是！！我要讲讲大家喜闻乐见的玄学算法：随机化" class="headerlink" title="但是！！我要讲讲大家喜闻乐见的玄学算法：随机化"></a>但是！！我要讲讲大家喜闻乐见的玄学算法：随机化</h3><p>随机化的代码一般很简短，仅仅是简单的模拟而已。</p><p>$Q1$：为什么这题可以随机化？</p><p>$A1$：这道题题目简单，数据种类少，数据关联性小，正常遍历数量大，所以考虑随机化优化时间复杂度。</p><p>$Q2$：随机化不是很玄吗？$WA$会不会霸屏？</p><a id="more"></a>




<p>$A2$：就一般的随机化而言，$WA$是在所难免的，由于随机化属于骗分技巧，所以可以说你的$rp$和调参水平决定了你的分数。</p>
<hr>
<p>那么这道题怎么随机化？</p>
<p>我们不妨从随机的对象说起：我们问的是选择其中的一些数，使得$mod$后最大，我们就可以像<a href="https://www.luogu.org/blog/firstfan/SA-solves-Package" target="_blank" rel="noopener">背包问题的模拟退火解决</a>（感兴趣的可以看看）那样，随机化选择或者不选。</p>
<p>模拟退火的操作需要产生能量差，所以本题我直接进行基本随机化：</p>
<blockquote>
<p>$rand()$重复次数，$rand()$选择个数，$rand()$选择数字。</p>
</blockquote>
<p>三重$rand()$的稳定性较低，所以循环常数不能小。但是循环常数大了容易$TLE$，所以调参对于一名合格的<del>randomer</del>OIer相当重要，这里我开的常数在$50000±3000$，能够保证在500ms左右，正确率$80%-90%$。</p>
<p><img src="https://i.loli.net/2019/03/24/5c973d7c60899.png" alt></p>
<p>Here’s my code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"O3"</span>)<span class="comment">//O3优化对于平时练习时的卡常有奇效</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		num=(num&lt;&lt;<span class="number">1</span>)+(num&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;<span class="comment">//快读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20031125</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((time)(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> n=read();</span><br><span class="line">	<span class="keyword">int</span> mod=read();</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=read();</span><br><span class="line">	&#125;<span class="comment">//输入数据</span></span><br><span class="line">	<span class="keyword">int</span> rnd=rand()%<span class="number">3000</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>+rnd;i++)<span class="comment">//随机循环次数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(ri j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//清空vis数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			vis[j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ri j=<span class="number">1</span>;j&lt;=rand()%n+<span class="number">1</span>;j++)<span class="comment">//随机选择个数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> rd=rand()%n+<span class="number">1</span>;<span class="comment">//随机选择数字</span></span><br><span class="line">			<span class="keyword">if</span>(vis[rd])<span class="comment">//剪枝</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans=max(ans,(ans+a[rd])%mod);<span class="comment">//更新答案</span></span><br><span class="line">			vis[rd]=<span class="literal">true</span>;<span class="comment">//打标记</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-CF154D</title>
    <url>/2019/11/23/CF154D/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题意翻译（略长，请耐心看完）</span><br><span class="line"></span><br><span class="line">一个独木桥上甲乙二人在玩传送游戏，其规则如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>开始时，甲乙二人分别位于x1,x2处，且甲先手。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>根据给定的参数a,b，二人可以在桥上传送：每一回合中，假定甲乙现在坐标为x1,x2，那么甲可以传送到[x1+a,x1+b]这一区间内的任一点上，而乙则可以传送到[x2-b,x2-a]上的任一点上，传送时允许跨越对手所在点（毕竟是传送）。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>胜利的条件：在本方传送后成功到达对手所在点(把对手挤下桥)。</span><br><span class="line"></span><br><span class="line">现问：在双方都足够聪明的情况下，谁会胜利？</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line"></span><br><span class="line">若甲胜利，输出“FIRST”，并在下一行指出此时甲第一步应该传送到的坐标。</span><br><span class="line"></span><br><span class="line">若乙胜利，输出“SECOND”。</span><br><span class="line"></span><br><span class="line">若比赛无法结束，输出“DRAW”。（注意：仅甲胜利时需要输出第二行。）</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">数据：</span><br><span class="line">输入仅一行四个整数：x1,x2,a,b。上述量均在[<span class="number">-1e9</span>,<span class="number">1e9</span>]范围内，且保证a≤b</span><br><span class="line"></span><br><span class="line">* 特殊地，当a,b异号时，呆在原地不动也是合法操作。</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>题目描述在暗示a,b的符号性很重要，我们就以此分类：</p>
<h3 id="此处设dis为二人初始位置差，即x2-x1"><a href="#此处设dis为二人初始位置差，即x2-x1" class="headerlink" title="*此处设dis为二人初始位置差，即x2-x1"></a>*此处设dis为二人初始位置差，即x2-x1</h3><ul>
<li>a,b均正</li>
</ul>
<p>1.甲乙只能背向前进，根本无法相遇，平局。(dis&lt;0)</p>
<p>2.甲乙相向而行，判断甲能获胜的条件：dis%(a+b)∈[a,b]。</p>
<blockquote>
<p>这种情况下，最终一步始终由甲来完成。甲第一步要到<code>x2-(dis*(a+b))*(a+b)</code>处，乙就无法逃脱。</p>
</blockquote>
<p>3.甲乙相向而行，乙能获胜的情况仅有一种：dis%(a+b)=0</p>
<blockquote>
<p>这种情况下，乙会恰好完成最后一步从而扼杀甲的下一步。</p>
</blockquote>
<ul>
<li>a负b正</li>
</ul>
<blockquote>
<p>这种条件下是可以呆在原地的，甲必须一发制敌，否则一定会陷入平局。</p>
</blockquote>
<p>1.一发制敌，直接传送到x2处</p>
<p>2.无法到达x2，进入平局。</p>
<ul>
<li>a,b均负</li>
</ul>
<blockquote>
<p>这种情况比较巧妙，我们考虑把桥倒过来，a,b再取绝对值并易位一下（因为-b≤-a），就可以调用第一种情况的结论了。</p>
</blockquote>
<p>讨论完了，上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flg=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flg=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">	&#123;</span><br><span class="line">		num=(num&lt;&lt;<span class="number">1</span>)+(num&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num*flg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dire=<span class="number">1</span>;<span class="comment">//记录桥方向是否倒转</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1=read();</span><br><span class="line">	<span class="keyword">int</span> x2=read();</span><br><span class="line">	<span class="keyword">int</span> dis=x2-x1;</span><br><span class="line">	<span class="keyword">int</span> a=read();</span><br><span class="line">	<span class="keyword">int</span> b=read();</span><br><span class="line">	<span class="keyword">if</span>(a&lt;=<span class="number">0</span>&amp;&amp;b&lt;=<span class="number">0</span>)<span class="comment">//均负</span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(a,b);</span><br><span class="line">		a=-a;</span><br><span class="line">		b=-b;</span><br><span class="line">		dis=-dis;</span><br><span class="line">		dire=-dire;<span class="comment">//反向</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;=<span class="number">0</span>)<span class="comment">//异号</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;=dis&amp;&amp;dis&lt;=b)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"FIRST"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>&amp;<span class="built_in">printf</span>(<span class="string">"%d"</span>,x2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//甲不能一发制敌</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>&amp;(<span class="keyword">int</span>)<span class="built_in">puts</span>(<span class="string">"DRAW"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//两种情况：</span></span><br><span class="line">	<span class="comment">//1.本来就均正</span></span><br><span class="line">	<span class="comment">//2.翻转后均正</span></span><br><span class="line">	<span class="keyword">if</span>(dis&lt;<span class="number">0</span>)<span class="comment">//南辕北辙</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>&amp;(<span class="keyword">int</span>)<span class="built_in">puts</span>(<span class="string">"DRAW"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(dis%(a+b)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>&amp;(<span class="keyword">int</span>)<span class="built_in">puts</span>(<span class="string">"SECOND"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=dis%(a+b)&amp;&amp;dis%(a+b)&lt;=b)<span class="comment">//甲胜</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"FIRST"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>&amp;<span class="built_in">printf</span>(<span class="string">"%d"</span>,x2-dire*(dis/(a+b))*(a+b));<span class="comment">//方向得用上。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//平局</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>&amp;(<span class="keyword">int</span>)<span class="built_in">puts</span>(<span class="string">"DRAW"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规律其实可以由搜索得到，感兴趣的读者可以亲手试试找规律的过程。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题的二进制解法</title>
    <url>/2019/11/23/binary_hanoi/</url>
    <content><![CDATA[<h3 id="想必来到这篇文章的人都知道汉诺塔是什么："><a href="#想必来到这篇文章的人都知道汉诺塔是什么：" class="headerlink" title="想必来到这篇文章的人都知道汉诺塔是什么："></a>想必来到这篇文章的人都知道汉诺塔是什么：</h3><p>三根柱子，一摞盘子，小盘在大盘上，挪到目标柱上。</p><p>如图：</p><p><img src="https://ww1.sinaimg.cn/large/007i4MEmly1g1l7lbfvmhg30ie0cidp0.gif" alt></p><p>这是学习语言理解递归最最基本的一个程序。</p><p>想想正常的做法：</p><ul>
<li><p>视角换至最底层盘，则要把所有上面的盘移动至无关盘上。</p>
</li>
<li><p>随后把最底层盘挪至目标处，转换为少一个盘的相同问题。</p>
</li>
<li><p>重复上述操作，直到只剩1个，放到目标盘即可。</p>
</li>
</ul><a id="more"></a>





<p>典型的递归思路。</p>
<hr>
<p>但我接下来要说的是它与<strong>二进制数</strong>的关系</p>
<p>我在玩汉诺塔时，发现一个很有意思的现象：</p>
<p>如果你用二进制数记录你每次的挪动的话，就会像这样：（从上至下依次编号$1-n$）</p>
<ul>
<li>未挪动时</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f63145c15d.png" alt></p>
<ul>
<li>挪动$1$号盘至$C$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f6386960e5.png" alt></p>
<ul>
<li>挪动$2$号盘到$B$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f63b76187c.png" alt></p>
<ul>
<li>挪动$1$号盘到$B$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f63ef17142.png" alt></p>
<ul>
<li>挪动$3$号盘到$C$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f6428ce753.png" alt></p>
<ul>
<li>挪动$1$号盘到$A$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f648e5c78e.png" alt></p>
<ul>
<li>挪动$2$号盘到$C$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f64d6e773b.png" alt></p>
<ul>
<li>挪动$1$号盘到$C$柱</li>
</ul>
<p><img src="https://i.loli.net/2019/03/30/5c9f65154ce95.png" alt></p>
<ul>
<li>$The$ $End$</li>
</ul>
<p>那么，我们来看看，这跟二进制又有什么关系呢？</p>
<p>先看挪$1$号盘时出现的变化：</p>
<p><img src="https://i.loli.net/2019/03/30/5c9f66427ea5f.png" alt></p>
<p>怎样？是不是发现了什么？</p>
<p>没错！就是说：当$lowbit(cnt)=10_{(2)}$时，即第二位为1时，下一次就要挪动$1$号盘。</p>
<p><code>再具体一点，我们甚至可以知道怎么挪一号盘</code></p>
<p>因为$1$号盘是最小的，所以他挪动时可以任意摆放，也就是说你<code>可以挪动到剩余两个柱子中的任意一个上</code></p>
<p>但最优解法只有一种，那么我们回过头去看1是怎么挪的：</p>
<blockquote>
<p>我们发现：</p>
</blockquote>
<blockquote>
<p>它的轨迹是$A$-&gt;$C$-&gt;$B$-&gt;$A$-&gt;$C$</p>
</blockquote>
<blockquote>
<p>这说明：它其实<strong>一直在向左挪动</strong></p>
</blockquote>
<blockquote>
<p>只不过到$A$时把$C$视作左柱而已。</p>
</blockquote>
<h3 id="惊人的结论-1"><a href="#惊人的结论-1" class="headerlink" title="惊人的结论$1$"></a>惊人的结论$1$</h3><ul>
<li>当$lowbit(cnt)=10_{(2)}$时，即第二位为1时，我们把$1$盘向左移动，其移动方向为$C-&gt;B-&gt;A-&gt;C$的一个<strong>环路径</strong>。</li>
</ul>
<p>那我们继续，看盘$2$的移动:</p>
<p><img src="https://i.loli.net/2019/03/30/5c9f6d184f5b2.png" alt></p>
<p>我们发现，二号盘总是被迫挪动到<strong>唯一的能挪动到的盘</strong>。</p>
<p>继而发现$2-n$号盘具有同一特性：总是被迫挪动到<strong>唯一的能挪动到的盘</strong>。</p>
<p>好了！现在我们可以进行非递归的解决了！</p>
<p>$move(cnt)_ {\ \ \ \ \ (\ cnt\mod\ 2\ =\ 1)} =\begin{cases}to\ \ left\ \ stick&amp;(\ cnt\mod\ 2\ =\ 1) \to\ \ empty\ \ stick&amp;(\ cnt\mod\ 2\ =\ 0)\end{cases}$ </p>
<p>当然，细心的同学可能发现了：为什么$move$函数会有一个$(\ cnt\mod\ 2\ =\ 1)$的条件呢？</p>
<ul>
<li>我们来看一看：</li>
</ul>
<p>我们讨论过$3$个盘的情况，再来讨论$4$个盘。</p>
<p>显然，我们由递推的思想得到，只要把$1-3$盘按照刚刚的思想挪到$C$柱，再把$4$盘挪到$B$柱，再用与之前按相同的步数挪到$4$的上面就好了。</p>
<ul>
<li><code>是不是有什么不对？</code></li>
</ul>
<p>是的！！我们成功地把四个盘子挪到了$B$柱上，而不是$C$柱！</p>
<ul>
<li>怎么办？</li>
</ul>
<p>当然是改变策略：每次把最小的盘$1$<strong>向右挪</strong></p>
<p>这样，我们由递推得到把$3$个盘子转移到了$B$上，接下来我们只要把$4$盘挪到$C$柱，再把三个盘挪到$4$盘的上方即可，这样是满足条件的。</p>
<ul>
<li>那么我们再写一个式子：</li>
</ul>
<p>$move(cnt)_ {\ \ \ \ \ (\ cnt\mod\ 2\ =\ 0)} =\begin{cases}to\ \ right\ \ stick&amp;(\ cnt\mod\ 2\ =\ 1) \to\ \ empty\ \ stick&amp;(\ cnt\mod\ 2\ =\ 0)\end{cases}$</p>
<hr>
<ul>
<li>二进制的解决方法到这里就结束了，那么为什么呢?</li>
</ul>
<p><code>还是递归</code></p>
<ul>
<li>我们看二进制是如何进位的：</li>
</ul>
<p>我们假设第$k$位发生$0-&gt;1$的更新即此盘的移动，那么我们要移动第$m$个盘，就一定要把<strong>二进制数</strong>$cnt$的<strong>第$m$位前面的所有位都更新为$0$并向$m$位进位</strong>。</p>
<ul>
<li>想起什么没有？</li>
</ul>
<p>我们在挪动汉诺塔时，挪动从上到下第$m$个盘时，要把它上面的所有$m-1$个盘都挪走！那么就是要把前面$m-1$位的$1$全部进位。</p>
<p>原理也解释完毕了，想必大家也理解了，下面有一个$6$盘汉诺塔，大家可以手动试试看。</p>
<p><img src="https://img2018.cnblogs.com/blog/1151747/201811/1151747-20181112155128542-1721696370.gif" alt></p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.$000001$</td>
</tr>
<tr>
<td align="center">2.$000010$</td>
</tr>
<tr>
<td align="center">3.$000011$</td>
</tr>
<tr>
<td align="center">4.$000100$</td>
</tr>
<tr>
<td align="center">5.$000101$</td>
</tr>
<tr>
<td align="center">6.$000110$</td>
</tr>
<tr>
<td align="center">7.$000111$</td>
</tr>
<tr>
<td align="center">……</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
